// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.time.ZoneId`
///
/// A time-zone ID, such as {@code Europe/Paris}.
///
/// A {@code ZoneId} is used to identify the rules used to convert between
/// an Instant and a LocalDateTime.
/// There are two distinct types of ID:
/// <ul>
/// <li>Fixed offsets - a fully resolved offset from UTC/Greenwich, that uses
///  the same offset for all local date-times
/// <li>Geographical regions - an area where a specific set of rules for finding
///  the offset from UTC/Greenwich apply
/// </ul>
/// Most fixed offsets are represented by ZoneOffset.
/// Calling \#normalized() on any {@code ZoneId} will ensure that a
/// fixed offset ID will be represented as a {@code ZoneOffset}.
///
/// The actual rules, describing when and how the offset changes, are defined by ZoneRules.
/// This class is simply an ID used to obtain the underlying rules.
/// This approach is taken because rules are defined by governments and change
/// frequently, whereas the ID is stable.
///
/// The distinction has other effects. Serializing the {@code ZoneId} will only send
/// the ID, whereas serializing the rules sends the entire data set.
/// Similarly, a comparison of two IDs only examines the ID, whereas
/// a comparison of two rules examines the entire data set.
///
/// <h3>Time-zone IDs</h3>
/// The ID is unique within the system.
/// There are three types of ID.
///
/// The simplest type of ID is that from {@code ZoneOffset}.
/// This consists of 'Z' and IDs starting with '+' or '-'.
///
/// The next type of ID are offset-style IDs with some form of prefix,
/// such as 'GMT+2' or 'UTC+01:00'.
/// The recognised prefixes are 'UTC', 'GMT' and 'UT'.
/// The offset is the suffix and will be normalized during creation.
/// These IDs can be normalized to a {@code ZoneOffset} using {@code normalized()}.
///
/// The third type of ID are region-based IDs. A region-based ID must be of
/// two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'.
/// Region-based IDs are defined by configuration, see ZoneRulesProvider.
/// The configuration focuses on providing the lookup from the ID to the
/// underlying {@code ZoneRules}.
///
/// Time-zone rules are defined by governments and change frequently.
/// There are a number of organizations, known here as groups, that monitor
/// time-zone changes and collate them.
/// The default group is the IANA Time Zone Database (TZDB).
/// Other organizations include IATA (the airline industry body) and Microsoft.
///
/// Each group defines its own format for the region ID it provides.
/// The TZDB group defines IDs such as 'Europe/London' or 'America/New_York'.
/// TZDB IDs take precedence over other groups.
///
/// It is strongly recommended that the group name is included in all IDs supplied by
/// groups other than TZDB to avoid conflicts. For example, IATA airline time-zone
/// region IDs are typically the same as the three letter airport code.
/// However, the airport of Utrecht has the code 'UTC', which is obviously a conflict.
/// The recommended format for region IDs from groups other than TZDB is 'group~region'.
/// Thus if IATA data were defined, Utrecht airport would be 'IATA~UTC'.
///
/// <h3>Serialization</h3>
/// This class can be serialized and stores the string zone ID in the external form.
/// The {@code ZoneOffset} subclass uses a dedicated format that only stores the
/// offset from UTC/Greenwich.
///
/// A {@code ZoneId} can be deserialized in a Java Runtime where the ID is unknown.
/// For example, if a server-side Java Runtime has been updated with a new zone ID, but
/// the client-side Java Runtime has not been updated. In this case, the {@code ZoneId}
/// object will exist, and can be queried using {@code getId}, {@code equals},
/// {@code hashCode}, {@code toString}, {@code getDisplayName} and {@code normalized}.
/// However, any call to {@code getRules} will fail with {@code ZoneRulesException}.
/// This approach is designed to allow a ZonedDateTime to be loaded and
/// queried, but not modified, on a Java Runtime with incomplete time-zone information.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZoneId} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This abstract class has two implementations, both of which are immutable and thread-safe.
/// One implementation models region-based IDs, the other is {@code ZoneOffset} modelling
/// offset-based IDs. This difference is visible in serialization.
///@since 1.8
class ZoneId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneId> $type;

  @jni$_.internal
  ZoneId.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneId$NullableType();
  static const type = $ZoneId$Type();
  static final _id_SHORT_IDS = _class.staticFieldId(r'SHORT_IDS', r'Ljava/util/Map;');

  /// from: `static public final java.util.Map<java.lang.String,java.lang.String> SHORT_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A map of zone overrides to enable the short time-zone names to be used.
  ///
  /// Use of short zone IDs has been deprecated in {@code java.util.TimeZone}.
  /// This map allows the IDs to continue to be used via the
  /// \#of(String, Map) factory method.
  ///
  /// This map contains a mapping of the IDs that is in line with TZDB 2005r and
  /// later, where 'EST', 'MST' and 'HST' map to IDs which do not include daylight
  /// savings.
  ///
  /// This maps as follows:
  /// <ul>
  /// <li>EST - -05:00</li>
  /// <li>HST - -10:00</li>
  /// <li>MST - -07:00</li>
  /// <li>ACT - Australia/Darwin</li>
  /// <li>AET - Australia/Sydney</li>
  /// <li>AGT - America/Argentina/Buenos_Aires</li>
  /// <li>ART - Africa/Cairo</li>
  /// <li>AST - America/Anchorage</li>
  /// <li>BET - America/Sao_Paulo</li>
  /// <li>BST - Asia/Dhaka</li>
  /// <li>CAT - Africa/Harare</li>
  /// <li>CNT - America/St_Johns</li>
  /// <li>CST - America/Chicago</li>
  /// <li>CTT - Asia/Shanghai</li>
  /// <li>EAT - Africa/Addis_Ababa</li>
  /// <li>ECT - Europe/Paris</li>
  /// <li>IET - America/Indiana/Indianapolis</li>
  /// <li>IST - Asia/Kolkata</li>
  /// <li>JST - Asia/Tokyo</li>
  /// <li>MIT - Pacific/Apia</li>
  /// <li>NET - Asia/Yerevan</li>
  /// <li>NST - Pacific/Auckland</li>
  /// <li>PLT - Asia/Karachi</li>
  /// <li>PNT - America/Phoenix</li>
  /// <li>PRT - America/Puerto_Rico</li>
  /// <li>PST - America/Los_Angeles</li>
  /// <li>SST - Pacific/Guadalcanal</li>
  /// <li>VST - Asia/Ho_Chi_Minh</li>
  /// </ul>
  /// The map is unmodifiable.
  static jni$_.JMap<jni$_.JString?, jni$_.JString?>? get SHORT_IDS => _id_SHORT_IDS.get(
    _class,
    const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
      jni$_.JStringNullableType(),
      jni$_.JStringNullableType(),
    ),
  );

  static final _id_systemDefault = _class.staticMethodId(r'systemDefault', r'()Ljava/time/ZoneId;');

  static final _systemDefault =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public java.time.ZoneId systemDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the system default time-zone.
  ///
  /// This queries TimeZone\#getDefault() to find the default time-zone
  /// and converts it to a {@code ZoneId}. If the system default time-zone is changed,
  /// then the result of this method will also change.
  ///@return the zone ID, not null
  ///@throws DateTimeException if the converted zone ID has an invalid format
  ///@throws ZoneRulesException if the converted zone region ID cannot be found
  static ZoneId? systemDefault() {
    return _systemDefault(
      _class.reference.pointer,
      _id_systemDefault as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getAvailableZoneIds = _class.staticMethodId(r'getAvailableZoneIds', r'()Ljava/util/Set;');

  static final _getAvailableZoneIds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public java.util.Set<java.lang.String> getAvailableZoneIds()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the set of available zone IDs.
  ///
  /// This set includes the string form of all available region-based IDs.
  /// Offset-based zone IDs are not included in the returned set.
  /// The ID can be passed to \#of(String) to create a {@code ZoneId}.
  ///
  /// The set of zone IDs can increase over time, although in a typical application
  /// the set of IDs is fixed. Each call to this method is thread-safe.
  ///@return a modifiable copy of the set of zone IDs, not null
  static jni$_.JSet<jni$_.JString?>? getAvailableZoneIds() {
    return _getAvailableZoneIds(
      _class.reference.pointer,
      _id_getAvailableZoneIds as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(const jni$_.JSetNullableType<jni$_.JString?>(jni$_.JStringNullableType()));
  }

  static final _id_of = _class.staticMethodId(r'of', r'(Ljava/lang/String;Ljava/util/Map;)Ljava/time/ZoneId;');

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String zoneId, java.util.Map<java.lang.String,java.lang.String> aliasMap)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} using its ID using a map
  /// of aliases to supplement the standard zone IDs.
  ///
  /// Many users of time-zones use short abbreviations, such as PST for
  /// 'Pacific Standard Time' and PDT for 'Pacific Daylight Time'.
  /// These abbreviations are not unique, and so cannot be used as IDs.
  /// This method allows a map of string to time-zone to be setup and reused
  /// within an application.
  ///@param zoneId the time-zone ID, not null
  ///@param aliasMap a map of alias zone IDs (typically abbreviations) to real zone IDs, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if the zone ID has an invalid format
  ///@throws ZoneRulesException if the zone ID is a region ID that cannot be found
  static ZoneId? of(jni$_.JString? zoneId, jni$_.JMap<jni$_.JString?, jni$_.JString?>? aliasMap) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    final _$aliasMap = aliasMap?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
      _$aliasMap.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(r'of', r'(Ljava/lang/String;)Ljava/time/ZoneId;');

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZoneId of(java.lang.String zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} from an ID ensuring that the
  /// ID is valid and available for use.
  ///
  /// This method parses the ID producing a {@code ZoneId} or {@code ZoneOffset}.
  /// A {@code ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.
  /// The result will always be a valid ID for which ZoneRules can be obtained.
  ///
  /// Parsing matches the zone ID step by step as follows.
  /// <ul>
  /// <li>If the zone ID equals 'Z', the result is {@code ZoneOffset.UTC}.
  /// <li>If the zone ID consists of a single letter, the zone ID is invalid
  ///  and {@code DateTimeException} is thrown.
  /// <li>If the zone ID starts with '+' or '-', the ID is parsed as a
  ///  {@code ZoneOffset} using ZoneOffset\#of(String).
  /// <li>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@code ZoneId}
  ///  with the same ID and rules equivalent to {@code ZoneOffset.UTC}.
  /// <li>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'
  ///  then the ID is a prefixed offset-based ID. The ID is split in two, with
  ///  a two or three letter prefix and a suffix starting with the sign.
  ///  The suffix is parsed as a ZoneOffset\#of(String) ZoneOffset.
  ///  The result will be a {@code ZoneId} with the specified UTC/GMT/UT prefix
  ///  and the normalized offset ID as per ZoneOffset\#getId().
  ///  The rules of the returned {@code ZoneId} will be equivalent to the
  ///  parsed {@code ZoneOffset}.
  /// <li>All other IDs are parsed as region-based zone IDs. Region IDs must
  ///  match the regular expression <code>[A-Za-z][A-Za-z0-9~/._+-]+</code>
  ///  otherwise a {@code DateTimeException} is thrown. If the zone ID is not
  ///  in the configured set of IDs, {@code ZoneRulesException} is thrown.
  ///  The detailed format of the region ID depends on the group supplying the data.
  ///  The default set of data is supplied by the IANA Time Zone Database (TZDB).
  ///  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.
  ///  This is compatible with most IDs from java.util.TimeZone.
  /// </ul>
  ///@param zoneId the time-zone ID, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if the zone ID has an invalid format
  ///@throws ZoneRulesException if the zone ID is a region ID that cannot be found
  static ZoneId? of$1(jni$_.JString? zoneId) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$zoneId.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_ofOffset = _class.staticMethodId(
    r'ofOffset',
    r'(Ljava/lang/String;Ljava/time/ZoneOffset;)Ljava/time/ZoneId;',
  );

  static final _ofOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZoneId ofOffset(java.lang.String prefix, java.time.ZoneOffset offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} wrapping an offset.
  ///
  /// If the prefix is "GMT", "UTC", or "UT" a {@code ZoneId}
  /// with the prefix and the non-zero offset is returned.
  /// If the prefix is empty {@code ""} the {@code ZoneOffset} is returned.
  ///@param prefix the time-zone ID, not null
  ///@param offset the offset, not null
  ///@return the zone ID, not null
  ///@throws IllegalArgumentException if the prefix is not one of
  ///     "GMT", "UTC", or "UT", or ""
  static ZoneId? ofOffset(jni$_.JString? prefix, ZoneOffset? offset) {
    final _$prefix = prefix?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _ofOffset(
      _class.reference.pointer,
      _id_ofOffset as jni$_.JMethodIDPtr,
      _$prefix.pointer,
      _$offset.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_from = _class.staticMethodId(r'from', r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneId;');

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZoneId from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} from a temporal object.
  ///
  /// This obtains a zone based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZoneId}.
  ///
  /// A {@code TemporalAccessor} represents some form of date and time information.
  /// This factory converts the arbitrary temporal object to an instance of {@code ZoneId}.
  ///
  /// The conversion will try to obtain the zone in a way that favours region-based
  /// zones over offset-based zones using TemporalQueries\#zone().
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZoneId::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if unable to convert to a {@code ZoneId}
  static ZoneId? from(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getId = _class.instanceMethodId(r'getId', r'()Ljava/lang/String;');

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the unique time-zone ID.
  ///
  /// This ID uniquely defines this object.
  /// The format of an offset based ID is defined by ZoneOffset\#getId().
  ///@return the time-zone unique ID, not null
  jni$_.JString? getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle style, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the textual representation of the zone, such as 'British Time' or
  /// '+02:00'.
  ///
  /// This returns the textual name used to identify the time-zone ID,
  /// suitable for presentation to the user.
  /// The parameters control the style of the returned text and the locale.
  ///
  /// If no textual mapping is found then the \#getId() full ID is returned.
  ///@param style the length of the text required, not null
  ///@param locale the locale to use, not null
  ///@return the text value of the zone, not null
  jni$_.JString? getDisplayName(jni$_.JObject? style, jni$_.JObject? locale) {
    final _$style = style?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
      reference.pointer,
      _id_getDisplayName as jni$_.JMethodIDPtr,
      _$style.pointer,
      _$locale.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(r'getRules', r'()Ljava/time/zone/ZoneRules;');

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public abstract java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the time-zone rules for this ID allowing calculations to be performed.
  ///
  /// The rules provide the functionality associated with a time-zone,
  /// such as finding the offset for a given instant or local date-time.
  ///
  /// A time-zone can be invalid if it is deserialized in a Java Runtime which
  /// does not have the same rules loaded as the Java Runtime that stored it.
  /// In this case, calling this method will throw a {@code ZoneRulesException}.
  ///
  /// The rules are supplied by ZoneRulesProvider. An advanced provider may
  /// support dynamic updates to the rules without restarting the Java Runtime.
  /// If so, then the result of this method may change over time.
  /// Each individual call will be still remain thread-safe.
  ///
  /// ZoneOffset will always return a set of rules where the offset never changes.
  ///@return the rules, not null
  ///@throws ZoneRulesException if no rules are available for this ID
  ZoneRules? getRules() {
    return _getRules(
      reference.pointer,
      _id_getRules as jni$_.JMethodIDPtr,
    ).object<ZoneRules?>(const $ZoneRules$NullableType());
  }

  static final _id_normalized = _class.instanceMethodId(r'normalized', r'()Ljava/time/ZoneId;');

  static final _normalized =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZoneId normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Normalizes the time-zone ID, returning a {@code ZoneOffset} where possible.
  ///
  /// The returns a normalized {@code ZoneId} that can be used in place of this ID.
  /// The result will have {@code ZoneRules} equivalent to those returned by this object,
  /// however the ID returned by {@code getId()} may be different.
  ///
  /// The normalization checks if the rules of this {@code ZoneId} have a fixed offset.
  /// If they do, then the {@code ZoneOffset} equal to that offset is returned.
  /// Otherwise {@code this} is returned.
  ///@return the time-zone unique ID, not null
  ZoneId? normalized() {
    return _normalized(
      reference.pointer,
      _id_normalized as jni$_.JMethodIDPtr,
    ).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(r'equals', r'(Ljava/lang/Object;)Z');

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this time-zone ID is equal to another time-zone ID.
  ///
  /// The comparison is based on the ID.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other time-zone ID
  bool equals(jni$_.JObject? obj) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this time-zone ID.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this zone as a {@code String}, using the ID.
  ///@return a string representation of this time-zone ID, not null
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneId$NullableType extends jni$_.JObjType<ZoneId?> {
  @jni$_.internal
  const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId? fromReference(jni$_.JReference reference) => reference.isNull ? null : ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$NullableType) && other is $ZoneId$NullableType;
  }
}

final class $ZoneId$Type extends jni$_.JObjType<ZoneId> {
  @jni$_.internal
  const $ZoneId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId fromReference(jni$_.JReference reference) => ZoneId.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$Type) && other is $ZoneId$Type;
  }
}

/// from: `java.time.ZonedDateTime`
///
/// A date-time with a time-zone in the ISO-8601 calendar system,
/// such as {@code 2007-12-03T10:15:30+01:00 Europe/Paris}.
///
/// {@code ZonedDateTime} is an immutable representation of a date-time with a time-zone.
/// This class stores all date and time fields, to a precision of nanoseconds,
/// and a time-zone, with a zone offset used to handle ambiguous local date-times.
/// For example, the value
/// "2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone"
/// can be stored in a {@code ZonedDateTime}.
///
/// This class handles conversion from the local time-line of {@code LocalDateTime}
/// to the instant time-line of {@code Instant}.
/// The difference between the two time-lines is the offset from UTC/Greenwich,
/// represented by a {@code ZoneOffset}.
///
/// Converting between the two time-lines involves calculating the offset using the
/// ZoneRules rules accessed from the {@code ZoneId}.
/// Obtaining the offset for an instant is simple, as there is exactly one valid
/// offset for each instant. By contrast, obtaining the offset for a local date-time
/// is not straightforward. There are three cases:
/// <ul>
/// <li>Normal, with one valid offset. For the vast majority of the year, the normal
///  case applies, where there is a single valid offset for the local date-time.</li>
/// <li>Gap, with zero valid offsets. This is when clocks jump forward typically
///  due to the spring daylight savings change from "winter" to "summer".
///  In a gap there are local date-time values with no valid offset.</li>
/// <li>Overlap, with two valid offsets. This is when clocks are set back typically
///  due to the autumn daylight savings change from "summer" to "winter".
///  In an overlap there are local date-time values with two valid offsets.</li>
/// </ul>
///
/// Any method that converts directly or implicitly from a local date-time to an
/// instant by obtaining the offset has the potential to be complicated.
///
/// For Gaps, the general strategy is that if the local date-time falls in the
/// middle of a Gap, then the resulting zoned date-time will have a local date-time
/// shifted forwards by the length of the Gap, resulting in a date-time in the later
/// offset, typically "summer" time.
///
/// For Overlaps, the general strategy is that if the local date-time falls in the
/// middle of an Overlap, then the previous offset will be retained. If there is no
/// previous offset, or the previous offset is invalid, then the earlier offset is
/// used, typically "summer" time.. Two additional methods,
/// \#withEarlierOffsetAtOverlap() and \#withLaterOffsetAtOverlap(),
/// help manage the case of an overlap.
///
/// In terms of design, this class should be viewed primarily as the combination
/// of a {@code LocalDateTime} and a {@code ZoneId}. The {@code ZoneOffset} is
/// a vital, but secondary, piece of information, used to ensure that the class
/// represents an instant, especially during a daylight savings overlap.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZonedDateTime} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec A {@code ZonedDateTime} holds state equivalent to three separate objects,
/// a {@code LocalDateTime}, a {@code ZoneId} and the resolved {@code ZoneOffset}.
/// The offset and local date-time are used to define an instant when necessary.
/// The zone ID is used to obtain the rules for how and when the offset changes.
/// The offset cannot be freely set, as the zone controls which offsets are valid.
///
/// This class is immutable and thread-safe.
///@since 1.8
class ZonedDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZonedDateTime> $type;

  @jni$_.internal
  ZonedDateTime.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZonedDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZonedDateTime$NullableType();
  static const type = $ZonedDateTime$Type();
  static final _id_now = _class.staticMethodId(r'now', r'()Ljava/time/ZonedDateTime;');

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public java.time.ZonedDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the system clock in the default time-zone.
  ///
  /// This will query the Clock\#systemDefaultZone() system clock in the default
  /// time-zone to obtain the current date-time.
  /// The zone and offset will be set based on the time-zone in the clock.
  ///
  /// Using this method will prevent the ability to use an alternate clock for testing
  /// because the clock is hard-coded.
  ///@return the current date-time using the system clock, not null
  static ZonedDateTime? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(r'now', r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;');

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the system clock in the specified time-zone.
  ///
  /// This will query the Clock\#system(ZoneId) system clock to obtain the current date-time.
  /// Specifying the time-zone avoids dependence on the default time-zone.
  /// The offset will be calculated from the specified time-zone.
  ///
  /// Using this method will prevent the ability to use an alternate clock for testing
  /// because the clock is hard-coded.
  ///@param zone the zone ID to use, not null
  ///@return the current date-time using the system clock, not null
  static ZonedDateTime? now$1(ZoneId? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(r'now', r'(Ljava/time/Clock;)Ljava/time/ZonedDateTime;');

  static final _now$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZonedDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the specified clock.
  ///
  /// This will query the specified clock to obtain the current date-time.
  /// The zone and offset will be set based on the time-zone in the clock.
  ///
  /// Using this method allows the use of an alternate clock for testing.
  /// The alternate clock may be introduced using Clock dependency injection.
  ///@param clock the clock to use, not null
  ///@return the current date-time, not null
  static ZonedDateTime? now$2(jni$_.JObject? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(
      _class.reference.pointer,
      _id_now$2 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDate date, java.time.LocalTime time, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date and time.
  ///
  /// This creates a zoned date-time matching the input local date and time as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date time and first combined to form a local date-time.
  /// The local date-time is then resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param date the local date, not null
  ///@param time the local time, not null
  ///@param zone the time-zone, not null
  ///@return the offset date-time, not null
  static ZonedDateTime? of(jni$_.JObject? date, jni$_.JObject? time, ZoneId? zone) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    final _$time = time?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$date.pointer,
      _$time.pointer,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date-time.
  ///
  /// This creates a zoned date-time matching the input local date-time as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param localDateTime the local date-time, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  static ZonedDateTime? of$1(jni$_.JObject? localDateTime, ZoneId? zone) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(r'of', r'(IIIIIIILjava/time/ZoneId;)Ljava/time/ZonedDateTime;');

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a year, month, day,
  /// hour, minute, second, nanosecond and time-zone.
  ///
  /// This creates a zoned date-time matching the local date-time of the seven
  /// specified fields as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///
  /// This method exists primarily for writing test cases.
  /// Non test-code will typically use other methods to create an offset time.
  /// {@code LocalDateTime} has five additional convenience variants of the
  /// equivalent factory method taking fewer arguments.
  /// They are not provided here to reduce the footprint of the API.
  ///@param year the year to represent, from MIN_YEAR to MAX_YEAR
  ///@param month the month-of-year to represent, from 1 (January) to 12 (December)
  ///@param dayOfMonth the day-of-month to represent, from 1 to 31
  ///@param hour the hour-of-day to represent, from 0 to 23
  ///@param minute the minute-of-hour to represent, from 0 to 59
  ///@param second the second-of-minute to represent, from 0 to 59
  ///@param nanoOfSecond the nano-of-second to represent, from 0 to 999,999,999
  ///@param zone the time-zone, not null
  ///@return the offset date-time, not null
  ///@throws DateTimeException if the value of any field is out of range, or
  ///  if the day-of-month is invalid for the month-year
  static ZonedDateTime? of$2(
    int year,
    int month,
    int dayOfMonth,
    int hour,
    int minute,
    int second,
    int nanoOfSecond,
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      year,
      month,
      dayOfMonth,
      hour,
      minute,
      second,
      nanoOfSecond,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofLocal = _class.staticMethodId(
    r'ofLocal',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;Ljava/time/ZoneOffset;)Ljava/time/ZonedDateTime;',
  );

  static final _ofLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofLocal(java.time.LocalDateTime localDateTime, java.time.ZoneId zone, java.time.ZoneOffset preferredOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date-time
  /// using the preferred offset if possible.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, where clocks are set back, there are two valid offsets.
  /// If the preferred offset is one of the valid offsets then it is used.
  /// Otherwise the earlier valid offset is used, typically corresponding to "summer".
  ///
  /// In the case of a gap, where clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param localDateTime the local date-time, not null
  ///@param zone the time-zone, not null
  ///@param preferredOffset the zone offset, null if no preference
  ///@return the zoned date-time, not null
  static ZonedDateTime? ofLocal(jni$_.JObject? localDateTime, ZoneId? zone, ZoneOffset? preferredOffset) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    final _$preferredOffset = preferredOffset?.reference ?? jni$_.jNullReference;
    return _ofLocal(
      _class.reference.pointer,
      _id_ofLocal as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$zone.pointer,
      _$preferredOffset.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from an {@code Instant}.
  ///
  /// This creates a zoned date-time with the same instant as that specified.
  /// Calling \#toInstant() will return an instant equal to the one used here.
  ///
  /// Converting an instant to a zoned date-time is simple as there is only one valid
  /// offset for each instant.
  ///@param instant the instant to create the date-time from, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if the result exceeds the supported range
  static ZonedDateTime? ofInstant(Instant? instant, ZoneId? zone) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofInstant(
      _class.reference.pointer,
      _id_ofInstant as jni$_.JMethodIDPtr,
      _$instant.pointer,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant$1 = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.LocalDateTime localDateTime, java.time.ZoneOffset offset, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from the instant formed by combining
  /// the local date-time and offset.
  ///
  /// This creates a zoned date-time by LocalDateTime\#toInstant(ZoneOffset) combining
  /// the {@code LocalDateTime} and {@code ZoneOffset}.
  /// This combination uniquely specifies an instant without ambiguity.
  ///
  /// Converting an instant to a zoned date-time is simple as there is only one valid
  /// offset for each instant. If the valid offset is different to the offset specified,
  /// then the date-time and offset of the zoned date-time will differ from those specified.
  ///
  /// If the {@code ZoneId} to be used is a {@code ZoneOffset}, this method is equivalent
  /// to \#of(LocalDateTime, ZoneId).
  ///@param localDateTime the local date-time, not null
  ///@param offset the zone offset, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  static ZonedDateTime? ofInstant$1(jni$_.JObject? localDateTime, ZoneOffset? offset, ZoneId? zone) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofInstant$1(
      _class.reference.pointer,
      _id_ofInstant$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$offset.pointer,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofStrict = _class.staticMethodId(
    r'ofStrict',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofStrict =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime ofStrict(java.time.LocalDateTime localDateTime, java.time.ZoneOffset offset, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} strictly validating the
  /// combination of local date-time, offset and zone ID.
  ///
  /// This creates a zoned date-time ensuring that the offset is valid for the
  /// local date-time according to the rules of the specified zone.
  /// If the offset is invalid, an exception is thrown.
  ///@param localDateTime the local date-time, not null
  ///@param offset the zone offset, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if the combination of arguments is invalid
  static ZonedDateTime? ofStrict(jni$_.JObject? localDateTime, ZoneOffset? offset, ZoneId? zone) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofStrict(
      _class.reference.pointer,
      _id_ofStrict as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$offset.pointer,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZonedDateTime;',
  );

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a temporal object.
  ///
  /// This obtains a zoned date-time based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZonedDateTime}.
  ///
  /// The conversion will first obtain a {@code ZoneId} from the temporal object,
  /// falling back to a {@code ZoneOffset} if necessary. It will then try to obtain
  /// an {@code Instant}, falling back to a {@code LocalDateTime} if necessary.
  /// The result will be either the combination of {@code ZoneId} or {@code ZoneOffset}
  /// with {@code Instant} or {@code LocalDateTime}.
  /// Implementations are permitted to perform optimizations such as accessing
  /// those fields that are equivalent to the relevant objects.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZonedDateTime::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if unable to convert to an {@code ZonedDateTime}
  static ZonedDateTime? from(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(r'parse', r'(Ljava/lang/CharSequence;)Ljava/time/ZonedDateTime;');

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a text string such as
  /// {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.
  ///
  /// The string must represent a valid date-time and is parsed using
  /// java.time.format.DateTimeFormatter\#ISO_ZONED_DATE_TIME.
  ///@param text the text to parse such as "2007-12-03T10:15:30+01:00[Europe/Paris]", not null
  ///@return the parsed zoned date-time, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static ZonedDateTime? parse(jni$_.JObject? text) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/ZonedDateTime;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence text, java.time.format.DateTimeFormatter formatter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a text string using a specific formatter.
  ///
  /// The text is parsed using the formatter, returning a date-time.
  ///@param text the text to parse, not null
  ///@param formatter the formatter to use, not null
  ///@return the parsed zoned date-time, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static ZonedDateTime? parse$1(jni$_.JObject? text, DateTimeFormatter? formatter) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$formatter = formatter?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$text.pointer,
      _$formatter.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(r'isSupported', r'(Ljava/time/temporal/TemporalField;)Z');

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this date-time can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range,
  /// \#get(TemporalField) get and \#with(TemporalField, long)
  /// methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The supported fields are:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND}
  /// <li>{@code NANO_OF_DAY}
  /// <li>{@code MICRO_OF_SECOND}
  /// <li>{@code MICRO_OF_DAY}
  /// <li>{@code MILLI_OF_SECOND}
  /// <li>{@code MILLI_OF_DAY}
  /// <li>{@code SECOND_OF_MINUTE}
  /// <li>{@code SECOND_OF_DAY}
  /// <li>{@code MINUTE_OF_HOUR}
  /// <li>{@code MINUTE_OF_DAY}
  /// <li>{@code HOUR_OF_AMPM}
  /// <li>{@code CLOCK_HOUR_OF_AMPM}
  /// <li>{@code HOUR_OF_DAY}
  /// <li>{@code CLOCK_HOUR_OF_DAY}
  /// <li>{@code AMPM_OF_DAY}
  /// <li>{@code DAY_OF_WEEK}
  /// <li>{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}
  /// <li>{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}
  /// <li>{@code DAY_OF_MONTH}
  /// <li>{@code DAY_OF_YEAR}
  /// <li>{@code EPOCH_DAY}
  /// <li>{@code ALIGNED_WEEK_OF_MONTH}
  /// <li>{@code ALIGNED_WEEK_OF_YEAR}
  /// <li>{@code MONTH_OF_YEAR}
  /// <li>{@code PROLEPTIC_MONTH}
  /// <li>{@code YEAR_OF_ERA}
  /// <li>{@code YEAR}
  /// <li>{@code ERA}
  /// <li>{@code INSTANT_SECONDS}
  /// <li>{@code OFFSET_SECONDS}
  /// </ul>
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this date-time, false if not
  bool isSupported(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer, _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(r'isSupported', r'(Ljava/time/temporal/TemporalUnit;)Z');

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit unit)`
  ///
  /// Checks if the specified unit is supported.
  ///
  /// This checks if the specified unit can be added to, or subtracted from, this date-time.
  /// If false, then calling the \#plus(long, TemporalUnit) and
  /// \#minus(long, TemporalUnit) minus methods will throw an exception.
  ///
  /// If the unit is a ChronoUnit then the query is implemented here.
  /// The supported units are:
  /// <ul>
  /// <li>{@code NANOS}
  /// <li>{@code MICROS}
  /// <li>{@code MILLIS}
  /// <li>{@code SECONDS}
  /// <li>{@code MINUTES}
  /// <li>{@code HOURS}
  /// <li>{@code HALF_DAYS}
  /// <li>{@code DAYS}
  /// <li>{@code WEEKS}
  /// <li>{@code MONTHS}
  /// <li>{@code YEARS}
  /// <li>{@code DECADES}
  /// <li>{@code CENTURIES}
  /// <li>{@code MILLENNIA}
  /// <li>{@code ERAS}
  /// </ul>
  /// All other {@code ChronoUnit} instances will return false.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
  /// passing {@code this} as the argument.
  /// Whether the unit is supported is determined by the unit.
  ///@param unit the unit to check, null returns false
  ///@return true if the unit can be added/subtracted, false if not
  bool isSupported$1(jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer, _id_isSupported$1 as jni$_.JMethodIDPtr, _$unit.pointer).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This date-time is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$field.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(r'get', r'(Ljava/time/temporal/TemporalField;)I');

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this date-time as an {@code int}.
  ///
  /// This queries this date-time for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},
  /// {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too
  /// large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer).integer;
  }

  static final _id_getLong = _class.instanceMethodId(r'getLong', r'(Ljava/time/temporal/TemporalField;)J');

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this date-time as a {@code long}.
  ///
  /// This queries this date-time for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr, _$field.pointer).long;
  }

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'()Ljava/time/ZoneOffset;');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the zone offset, such as '+01:00'.
  ///
  /// This is the offset of the local date-time from UTC/Greenwich.
  ///@return the zone offset, not null
  ZoneOffset? getOffset() {
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_withEarlierOffsetAtOverlap = _class.instanceMethodId(
    r'withEarlierOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withEarlierOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZonedDateTime withEarlierOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time changing the zone offset to the
  /// earlier of the two valid offsets at a local time-line overlap.
  ///
  /// This method only has any effect when the local time-line overlaps, such as
  /// at an autumn daylight savings cutover. In this scenario, there are two
  /// valid offsets for the local date-time. Calling this method will return
  /// a zoned date-time with the earlier of the two selected.
  ///
  /// If this method is called when it is not an overlap, {@code this}
  /// is returned.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@return a {@code ZonedDateTime} based on this date-time with the earlier offset, not null
  ZonedDateTime? withEarlierOffsetAtOverlap() {
    return _withEarlierOffsetAtOverlap(
      reference.pointer,
      _id_withEarlierOffsetAtOverlap as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withLaterOffsetAtOverlap = _class.instanceMethodId(
    r'withLaterOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withLaterOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZonedDateTime withLaterOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time changing the zone offset to the
  /// later of the two valid offsets at a local time-line overlap.
  ///
  /// This method only has any effect when the local time-line overlaps, such as
  /// at an autumn daylight savings cutover. In this scenario, there are two
  /// valid offsets for the local date-time. Calling this method will return
  /// a zoned date-time with the later of the two selected.
  ///
  /// If this method is called when it is not an overlap, {@code this}
  /// is returned.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@return a {@code ZonedDateTime} based on this date-time with the later offset, not null
  ZonedDateTime? withLaterOffsetAtOverlap() {
    return _withLaterOffsetAtOverlap(
      reference.pointer,
      _id_withLaterOffsetAtOverlap as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(r'getZone', r'()Ljava/time/ZoneId;');

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the time-zone, such as 'Europe/Paris'.
  ///
  /// This returns the zone ID. This identifies the time-zone ZoneRules rules
  /// that determine when and how the offset from UTC/Greenwich changes.
  ///
  /// The zone ID may be same as the {@linkplain \#getOffset() offset}.
  /// If this is true, then any future calculations, such as addition or subtraction,
  /// have no complex edge cases due to time-zone rules.
  /// See also \#withFixedOffsetZone().
  ///@return the time-zone, not null
  ZoneId? getZone() {
    return _getZone(reference.pointer, _id_getZone as jni$_.JMethodIDPtr).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_withZoneSameLocal = _class.instanceMethodId(
    r'withZoneSameLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameLocal =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with a different time-zone,
  /// retaining the local date-time if possible.
  ///
  /// This method changes the time-zone and retains the local date-time.
  /// The local date-time is only changed if it is invalid for the new zone,
  /// determined using the same approach as
  /// \#ofLocal(LocalDateTime, ZoneId, ZoneOffset).
  ///
  /// To change the zone and adjust the local date-time,
  /// use \#withZoneSameInstant(ZoneId).
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param zone the time-zone to change to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the requested zone, not null
  ZonedDateTime? withZoneSameLocal(ZoneId? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _withZoneSameLocal(
      reference.pointer,
      _id_withZoneSameLocal as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameInstant = _class.instanceMethodId(
    r'withZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with a different time-zone,
  /// retaining the instant.
  ///
  /// This method changes the time-zone and retains the instant.
  /// This normally results in a change to the local date-time.
  ///
  /// This method is based on retaining the same instant, thus gaps and overlaps
  /// in the local time-line have no effect on the result.
  ///
  /// To change the offset while keeping the local time,
  /// use \#withZoneSameLocal(ZoneId).
  ///@param zone the time-zone to change to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the requested zone, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? withZoneSameInstant(ZoneId? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _withZoneSameInstant(
      reference.pointer,
      _id_withZoneSameInstant as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withFixedOffsetZone = _class.instanceMethodId(
    r'withFixedOffsetZone',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withFixedOffsetZone =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZonedDateTime withFixedOffsetZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the zone ID set to the offset.
  ///
  /// This returns a zoned date-time where the zone ID is the same as \#getOffset().
  /// The local date-time, offset and instant of the result will be the same as in this date-time.
  ///
  /// Setting the date-time to a fixed single offset means that any future
  /// calculations, such as addition or subtraction, have no complex edge cases
  /// due to time-zone rules.
  /// This might also be useful when sending a zoned date-time across a network,
  /// as most protocols, such as ISO-8601, only handle offsets,
  /// and not region-based zone IDs.
  ///
  /// This is equivalent to {@code ZonedDateTime.of(zdt.toLocalDateTime(), zdt.getOffset())}.
  ///@return a {@code ZonedDateTime} with the zone ID set to the offset, not null
  ZonedDateTime? withFixedOffsetZone() {
    return _withFixedOffsetZone(
      reference.pointer,
      _id_withFixedOffsetZone as jni$_.JMethodIDPtr,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(r'toLocalDateTime', r'()Ljava/time/LocalDateTime;');

  static final _toLocalDateTime =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalDateTime} part of this date-time.
  ///
  /// This returns a {@code LocalDateTime} with the same year, month, day and time
  /// as this date-time.
  ///@return the local date-time part of this date-time, not null
  jni$_.JObject? toLocalDateTime() {
    return _toLocalDateTime(
      reference.pointer,
      _id_toLocalDateTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalDate = _class.instanceMethodId(r'toLocalDate', r'()Ljava/time/LocalDate;');

  static final _toLocalDate =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalDate} part of this date-time.
  ///
  /// This returns a {@code LocalDate} with the same year, month and day
  /// as this date-time.
  ///@return the date part of this date-time, not null
  jni$_.JObject? toLocalDate() {
    return _toLocalDate(
      reference.pointer,
      _id_toLocalDate as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getYear = _class.instanceMethodId(r'getYear', r'()I');

  static final _getYear =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getYear()`
  ///
  /// Gets the year field.
  ///
  /// This method returns the primitive {@code int} value for the year.
  ///
  /// The year returned by this method is proleptic as per {@code get(YEAR)}.
  /// To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.
  ///@return the year, from MIN_YEAR to MAX_YEAR
  int getYear() {
    return _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(r'getMonthValue', r'()I');

  static final _getMonthValue =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getMonthValue()`
  ///
  /// Gets the month-of-year field from 1 to 12.
  ///
  /// This method returns the month as an {@code int} from 1 to 12.
  /// Application code is frequently clearer if the enum Month
  /// is used by calling \#getMonth().
  ///@return the month-of-year, from 1 to 12
  ///@see \#getMonth()
  int getMonthValue() {
    return _getMonthValue(reference.pointer, _id_getMonthValue as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getMonth = _class.instanceMethodId(r'getMonth', r'()Ljava/time/Month;');

  static final _getMonth =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the month-of-year field using the {@code Month} enum.
  ///
  /// This method returns the enum Month for the month.
  /// This avoids confusion as to what {@code int} values mean.
  /// If you need access to the primitive {@code int} value then the enum
  /// provides the Month\#getValue() int value.
  ///@return the month-of-year, not null
  ///@see \#getMonthValue()
  jni$_.JObject? getMonth() {
    return _getMonth(
      reference.pointer,
      _id_getMonth as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(r'getDayOfMonth', r'()I');

  static final _getDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getDayOfMonth()`
  ///
  /// Gets the day-of-month field.
  ///
  /// This method returns the primitive {@code int} value for the day-of-month.
  ///@return the day-of-month, from 1 to 31
  int getDayOfMonth() {
    return _getDayOfMonth(reference.pointer, _id_getDayOfMonth as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(r'getDayOfYear', r'()I');

  static final _getDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getDayOfYear()`
  ///
  /// Gets the day-of-year field.
  ///
  /// This method returns the primitive {@code int} value for the day-of-year.
  ///@return the day-of-year, from 1 to 365, or 366 in a leap year
  int getDayOfYear() {
    return _getDayOfYear(reference.pointer, _id_getDayOfYear as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(r'getDayOfWeek', r'()Ljava/time/DayOfWeek;');

  static final _getDayOfWeek =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the day-of-week field, which is an enum {@code DayOfWeek}.
  ///
  /// This method returns the enum DayOfWeek for the day-of-week.
  /// This avoids confusion as to what {@code int} values mean.
  /// If you need access to the primitive {@code int} value then the enum
  /// provides the DayOfWeek\#getValue() int value.
  ///
  /// Additional information can be obtained from the {@code DayOfWeek}.
  /// This includes textual names of the values.
  ///@return the day-of-week, not null
  jni$_.JObject? getDayOfWeek() {
    return _getDayOfWeek(
      reference.pointer,
      _id_getDayOfWeek as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(r'toLocalTime', r'()Ljava/time/LocalTime;');

  static final _toLocalTime =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalTime} part of this date-time.
  ///
  /// This returns a {@code LocalTime} with the same hour, minute, second and
  /// nanosecond as this date-time.
  ///@return the time part of this date-time, not null
  jni$_.JObject? toLocalTime() {
    return _toLocalTime(
      reference.pointer,
      _id_toLocalTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getHour = _class.instanceMethodId(r'getHour', r'()I');

  static final _getHour =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getHour()`
  ///
  /// Gets the hour-of-day field.
  ///@return the hour-of-day, from 0 to 23
  int getHour() {
    return _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getMinute = _class.instanceMethodId(r'getMinute', r'()I');

  static final _getMinute =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getMinute()`
  ///
  /// Gets the minute-of-hour field.
  ///@return the minute-of-hour, from 0 to 59
  int getMinute() {
    return _getMinute(reference.pointer, _id_getMinute as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getSecond = _class.instanceMethodId(r'getSecond', r'()I');

  static final _getSecond =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getSecond()`
  ///
  /// Gets the second-of-minute field.
  ///@return the second-of-minute, from 0 to 59
  int getSecond() {
    return _getSecond(reference.pointer, _id_getSecond as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getNano()`
  ///
  /// Gets the nano-of-second field.
  ///@return the nano-of-second, from 0 to 999,999,999
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/ZonedDateTime;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster adjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an adjusted copy of this date-time.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the date-time adjusted.
  /// The adjustment takes place using the specified adjuster strategy object.
  /// Read the documentation of the adjuster to understand what adjustment will be made.
  ///
  /// A simple adjuster might simply set the one of the fields, such as the year field.
  /// A more complex adjuster might set the date to the last day of the month.
  /// A selection of common adjustments is provided in
  /// java.time.temporal.TemporalAdjusters TemporalAdjusters.
  /// These include finding the "last day of the month" and "next Wednesday".
  /// Key date-time classes also implement the {@code TemporalAdjuster} interface,
  /// such as Month and java.time.MonthDay MonthDay.
  /// The adjuster is responsible for handling special cases, such as the varying
  /// lengths of month and leap years.
  ///
  /// For example this code returns a date on the last day of July:
  /// <pre>
  ///  import static java.time.Month.*;
  ///  import static java.time.temporal.TemporalAdjusters.*;
  ///
  ///  result = zonedDateTime.with(JULY).with(lastDayOfMonth());
  /// </pre>
  ///
  /// The classes LocalDate and LocalTime implement {@code TemporalAdjuster},
  /// thus this method can be used to change the date, time or offset:
  /// <pre>
  ///  result = zonedDateTime.with(date);
  ///  result = zonedDateTime.with(time);
  /// </pre>
  ///
  /// ZoneOffset also implements {@code TemporalAdjuster} however using it
  /// as an argument typically has no effect. The offset of a {@code ZonedDateTime} is
  /// controlled primarily by the time-zone. As such, changing the offset does not generally
  /// make sense, because there is only one valid offset for the local date-time and zone.
  /// If the zoned date-time is in a daylight savings overlap, then the offset is used
  /// to switch between the two valid offsets. In all other cases, the offset is ignored.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalAdjuster\#adjustInto(Temporal) method on the
  /// specified adjuster passing {@code this} as the argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param adjuster the adjuster to use, not null
  ///@return a {@code ZonedDateTime} based on {@code this} with the adjustment made, not null
  ///@throws DateTimeException if the adjustment cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? with$(jni$_.JObject? adjuster) {
    final _$adjuster = adjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$adjuster.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/ZonedDateTime;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)
          >();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalField field, long newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified field set to a new value.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the value
  /// for the specified field changed.
  /// This can be used to change any supported field, such as the year, month or day-of-month.
  /// If it is not possible to set the value, because the field is not supported or for
  /// some other reason, an exception is thrown.
  ///
  /// In some cases, changing the specified field can cause the resulting date-time to become invalid,
  /// such as changing the month from 31st January to February would make the day-of-month invalid.
  /// In cases like this, the field is responsible for resolving the date. Typically it will choose
  /// the previous valid date, which would be the last valid day of February in this example.
  ///
  /// If the field is a ChronoField then the adjustment is implemented here.
  ///
  /// The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.
  /// The zone and nano-of-second are unchanged.
  /// The result will have an offset derived from the new instant and original zone.
  /// If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.
  ///
  /// The {@code OFFSET_SECONDS} field will typically be ignored.
  /// The offset of a {@code ZonedDateTime} is controlled primarily by the time-zone.
  /// As such, changing the offset does not generally make sense, because there is only
  /// one valid offset for the local date-time and zone.
  /// If the zoned date-time is in a daylight savings overlap, then the offset is used
  /// to switch between the two valid offsets. In all other cases, the offset is ignored.
  /// If the new offset value is outside the valid range then a {@code DateTimeException} will be thrown.
  ///
  /// The other \#isSupported(TemporalField) supported fields will behave as per
  /// the matching method on LocalDateTime\#with(TemporalField, long) LocalDateTime.
  /// The zone is not part of the calculation and will be unchanged.
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the field determines
  /// whether and how to adjust the instant.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param field the field to set in the result, not null
  ///@param newValue the new value of the field in the result
  ///@return a {@code ZonedDateTime} based on {@code this} with the specified field set, not null
  ///@throws DateTimeException if the field cannot be set
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? with$1(jni$_.JObject? field, int newValue) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$field.pointer,
      newValue,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(r'withYear', r'(I)Ljava/time/ZonedDateTime;');

  static final _withYear =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withYear(int year)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withYear(int) changing the year of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param year the year to set in the result, from MIN_YEAR to MAX_YEAR
  ///@return a {@code ZonedDateTime} based on this date-time with the requested year, not null
  ///@throws DateTimeException if the year value is invalid
  ZonedDateTime? withYear(int year) {
    return _withYear(
      reference.pointer,
      _id_withYear as jni$_.JMethodIDPtr,
      year,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(r'withMonth', r'(I)Ljava/time/ZonedDateTime;');

  static final _withMonth =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMonth(int month)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the month-of-year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withMonth(int) changing the month of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param month the month-of-year to set in the result, from 1 (January) to 12 (December)
  ///@return a {@code ZonedDateTime} based on this date-time with the requested month, not null
  ///@throws DateTimeException if the month-of-year value is invalid
  ZonedDateTime? withMonth(int month) {
    return _withMonth(
      reference.pointer,
      _id_withMonth as jni$_.JMethodIDPtr,
      month,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(r'withDayOfMonth', r'(I)Ljava/time/ZonedDateTime;');

  static final _withDayOfMonth =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfMonth(int dayOfMonth)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the day-of-month altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withDayOfMonth(int) changing the day-of-month of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param dayOfMonth the day-of-month to set in the result, from 1 to 28-31
  ///@return a {@code ZonedDateTime} based on this date-time with the requested day, not null
  ///@throws DateTimeException if the day-of-month value is invalid,
  ///  or if the day-of-month is invalid for the month-year
  ZonedDateTime? withDayOfMonth(int dayOfMonth) {
    return _withDayOfMonth(
      reference.pointer,
      _id_withDayOfMonth as jni$_.JMethodIDPtr,
      dayOfMonth,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(r'withDayOfYear', r'(I)Ljava/time/ZonedDateTime;');

  static final _withDayOfYear =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfYear(int dayOfYear)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the day-of-year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withDayOfYear(int) changing the day-of-year of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param dayOfYear the day-of-year to set in the result, from 1 to 365-366
  ///@return a {@code ZonedDateTime} based on this date with the requested day, not null
  ///@throws DateTimeException if the day-of-year value is invalid,
  ///  or if the day-of-year is invalid for the year
  ZonedDateTime? withDayOfYear(int dayOfYear) {
    return _withDayOfYear(
      reference.pointer,
      _id_withDayOfYear as jni$_.JMethodIDPtr,
      dayOfYear,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(r'withHour', r'(I)Ljava/time/ZonedDateTime;');

  static final _withHour =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withHour(int hour)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the hour-of-day altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withHour(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hour the hour-of-day to set in the result, from 0 to 23
  ///@return a {@code ZonedDateTime} based on this date-time with the requested hour, not null
  ///@throws DateTimeException if the hour value is invalid
  ZonedDateTime? withHour(int hour) {
    return _withHour(
      reference.pointer,
      _id_withHour as jni$_.JMethodIDPtr,
      hour,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(r'withMinute', r'(I)Ljava/time/ZonedDateTime;');

  static final _withMinute =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMinute(int minute)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the minute-of-hour altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withMinute(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minute the minute-of-hour to set in the result, from 0 to 59
  ///@return a {@code ZonedDateTime} based on this date-time with the requested minute, not null
  ///@throws DateTimeException if the minute value is invalid
  ZonedDateTime? withMinute(int minute) {
    return _withMinute(
      reference.pointer,
      _id_withMinute as jni$_.JMethodIDPtr,
      minute,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(r'withSecond', r'(I)Ljava/time/ZonedDateTime;');

  static final _withSecond =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withSecond(int second)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the second-of-minute altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withSecond(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param second the second-of-minute to set in the result, from 0 to 59
  ///@return a {@code ZonedDateTime} based on this date-time with the requested second, not null
  ///@throws DateTimeException if the second value is invalid
  ZonedDateTime? withSecond(int second) {
    return _withSecond(
      reference.pointer,
      _id_withSecond as jni$_.JMethodIDPtr,
      second,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(r'withNano', r'(I)Ljava/time/ZonedDateTime;');

  static final _withNano =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withNano(int nanoOfSecond)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the nano-of-second altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withNano(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanoOfSecond the nano-of-second to set in the result, from 0 to 999,999,999
  ///@return a {@code ZonedDateTime} based on this date-time with the requested nanosecond, not null
  ///@throws DateTimeException if the nano value is invalid
  ZonedDateTime? withNano(int nanoOfSecond) {
    return _withNano(
      reference.pointer,
      _id_withNano as jni$_.JMethodIDPtr,
      nanoOfSecond,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the time truncated.
  ///
  /// Truncation returns a copy of the original date-time with fields
  /// smaller than the specified unit set to zero.
  /// For example, truncating with the ChronoUnit\#MINUTES minutes unit
  /// will set the second-of-minute and nano-of-second field to zero.
  ///
  /// The unit must have a {@linkplain TemporalUnit\#getDuration() duration}
  /// that divides into the length of a standard day without remainder.
  /// This includes all supplied time units on ChronoUnit and
  /// ChronoUnit\#DAYS DAYS. Other units throw an exception.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#truncatedTo(TemporalUnit) truncating
  /// the underlying local date-time. This is then converted back to a
  /// {@code ZonedDateTime}, using the zone ID to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param unit the unit to truncate to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the time truncated, not null
  ///@throws DateTimeException if unable to truncate
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ZonedDateTime? truncatedTo(jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$unit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount amountToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount added.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the specified amount added.
  /// The amount is typically Period or Duration but may be
  /// any other type implementing the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#addTo(Temporal). The amount implementation is free
  /// to implement the addition in any way it wishes, however it typically
  /// calls back to \#plus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount to add, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the addition made, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? plus(jni$_.JObject? amountToAdd) {
    final _$amountToAdd = amountToAdd?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$amountToAdd.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime plus(long amountToAdd, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount added.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the amount
  /// in terms of the unit added. If it is not possible to add the amount, because the
  /// unit is not supported or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoUnit then the addition is implemented here.
  /// The zone is not part of the calculation and will be unchanged in the result.
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line.
  /// The period is first added to the local date-time, then converted back
  /// to a zoned date-time using the zone ID.
  /// The conversion uses \#ofLocal(LocalDateTime, ZoneId, ZoneOffset)
  /// with the offset before the addition.
  ///
  /// Time units operate on the instant time-line.
  /// The period is first added to the local date-time, then converted back to
  /// a zoned date-time using the zone ID.
  /// The conversion uses \#ofInstant(LocalDateTime, ZoneOffset, ZoneId)
  /// with the offset before the addition.
  ///
  /// If the field is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the unit determines
  /// whether and how to perform the addition.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount of the unit to add to the result, may be negative
  ///@param unit the unit of the amount to add, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the specified amount added, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? plus$1(int amountToAdd, jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      amountToAdd,
      _$unit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(r'plusYears', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusYears =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusYears(long years)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of years added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusYears(long) adding years to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param years the years to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the years added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusYears(int years) {
    return _plusYears(
      reference.pointer,
      _id_plusYears as jni$_.JMethodIDPtr,
      years,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(r'plusMonths', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusMonths =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMonths(long months)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of months added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusMonths(long) adding months to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param months the months to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the months added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusMonths(int months) {
    return _plusMonths(
      reference.pointer,
      _id_plusMonths as jni$_.JMethodIDPtr,
      months,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(r'plusWeeks', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusWeeks(long weeks)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of weeks added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusWeeks(long) adding weeks to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param weeks the weeks to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the weeks added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusWeeks(int weeks) {
    return _plusWeeks(
      reference.pointer,
      _id_plusWeeks as jni$_.JMethodIDPtr,
      weeks,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(r'plusDays', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusDays =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusDays(long days)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of days added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusDays(long) adding days to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param days the days to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the days added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusDays(int days) {
    return _plusDays(
      reference.pointer,
      _id_plusDays as jni$_.JMethodIDPtr,
      days,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(r'plusHours', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusHours =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusHours(long hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of hours added.
  ///
  /// This operates on the instant time-line, such that adding one hour will
  /// always be a duration of one hour later.
  /// This may cause the local date-time to change by an amount other than one hour.
  /// Note that this is a different approach to that used by days, months and years,
  /// thus adding one day is not the same as adding 24 hours.
  ///
  /// For example, consider a time-zone, such as 'Europe/Paris', where the
  /// Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
  /// changing from offset +02:00 in summer to +01:00 in winter.
  /// <ul>
  /// <li>Adding one hour to 01:30+02:00 will result in 02:30+02:00
  ///     (both in summer time)
  /// <li>Adding one hour to 02:30+02:00 will result in 02:30+01:00
  ///     (moving from summer to winter time)
  /// <li>Adding one hour to 02:30+01:00 will result in 03:30+01:00
  ///     (both in winter time)
  /// <li>Adding three hours to 01:30+02:00 will result in 03:30+01:00
  ///     (moving from summer to winter time)
  /// </ul>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hours the hours to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the hours added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusHours(int hours) {
    return _plusHours(
      reference.pointer,
      _id_plusHours as jni$_.JMethodIDPtr,
      hours,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(r'plusMinutes', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMinutes(long minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of minutes added.
  ///
  /// This operates on the instant time-line, such that adding one minute will
  /// always be a duration of one minute later.
  /// This may cause the local date-time to change by an amount other than one minute.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minutes the minutes to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the minutes added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusMinutes(int minutes) {
    return _plusMinutes(
      reference.pointer,
      _id_plusMinutes as jni$_.JMethodIDPtr,
      minutes,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(r'plusSeconds', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusSeconds(long seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of seconds added.
  ///
  /// This operates on the instant time-line, such that adding one second will
  /// always be a duration of one second later.
  /// This may cause the local date-time to change by an amount other than one second.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param seconds the seconds to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the seconds added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusSeconds(int seconds) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      seconds,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(r'plusNanos', r'(J)Ljava/time/ZonedDateTime;');

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusNanos(long nanos)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of nanoseconds added.
  ///
  /// This operates on the instant time-line, such that adding one nano will
  /// always be a duration of one nano later.
  /// This may cause the local date-time to change by an amount other than one nano.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanos the nanos to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the nanoseconds added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusNanos(int nanos) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      nanos,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount amountToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount subtracted.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the specified amount subtracted.
  /// The amount is typically Period or Duration but may be
  /// any other type implementing the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#subtractFrom(Temporal). The amount implementation is free
  /// to implement the subtraction in any way it wishes, however it typically
  /// calls back to \#minus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount to subtract, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the subtraction made, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? minus(jni$_.JObject? amountToSubtract) {
    final _$amountToSubtract = amountToSubtract?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$amountToSubtract.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime minus(long amountToSubtract, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount subtracted.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the amount
  /// in terms of the unit subtracted. If it is not possible to subtract the amount,
  /// because the unit is not supported or for some other reason, an exception is thrown.
  ///
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line.
  /// The period is first subtracted from the local date-time, then converted back
  /// to a zoned date-time using the zone ID.
  /// The conversion uses \#ofLocal(LocalDateTime, ZoneId, ZoneOffset)
  /// with the offset before the subtraction.
  ///
  /// Time units operate on the instant time-line.
  /// The period is first subtracted from the local date-time, then converted back to
  /// a zoned date-time using the zone ID.
  /// The conversion uses \#ofInstant(LocalDateTime, ZoneOffset, ZoneId)
  /// with the offset before the subtraction.
  ///
  /// This method is equivalent to \#plus(long, TemporalUnit) with the amount negated.
  /// See that method for a full description of how addition, and thus subtraction, works.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount of the unit to subtract from the result, may be negative
  ///@param unit the unit of the amount to subtract, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the specified amount subtracted, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? minus$1(int amountToSubtract, jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      amountToSubtract,
      _$unit.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(r'minusYears', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusYears =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusYears(long years)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of years subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusYears(long) subtracting years to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param years the years to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the years subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusYears(int years) {
    return _minusYears(
      reference.pointer,
      _id_minusYears as jni$_.JMethodIDPtr,
      years,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(r'minusMonths', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusMonths =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMonths(long months)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of months subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusMonths(long) subtracting months to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param months the months to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the months subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusMonths(int months) {
    return _minusMonths(
      reference.pointer,
      _id_minusMonths as jni$_.JMethodIDPtr,
      months,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(r'minusWeeks', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusWeeks =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusWeeks(long weeks)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of weeks subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusWeeks(long) subtracting weeks to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param weeks the weeks to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the weeks subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusWeeks(int weeks) {
    return _minusWeeks(
      reference.pointer,
      _id_minusWeeks as jni$_.JMethodIDPtr,
      weeks,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(r'minusDays', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusDays =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusDays(long days)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of days subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusDays(long) subtracting days to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param days the days to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the days subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusDays(int days) {
    return _minusDays(
      reference.pointer,
      _id_minusDays as jni$_.JMethodIDPtr,
      days,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(r'minusHours', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusHours =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusHours(long hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of hours subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one hour will
  /// always be a duration of one hour earlier.
  /// This may cause the local date-time to change by an amount other than one hour.
  /// Note that this is a different approach to that used by days, months and years,
  /// thus subtracting one day is not the same as adding 24 hours.
  ///
  /// For example, consider a time-zone, such as 'Europe/Paris', where the
  /// Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
  /// changing from offset +02:00 in summer to +01:00 in winter.
  /// <ul>
  /// <li>Subtracting one hour from 03:30+01:00 will result in 02:30+01:00
  ///     (both in winter time)
  /// <li>Subtracting one hour from 02:30+01:00 will result in 02:30+02:00
  ///     (moving from winter to summer time)
  /// <li>Subtracting one hour from 02:30+02:00 will result in 01:30+02:00
  ///     (both in summer time)
  /// <li>Subtracting three hours from 03:30+01:00 will result in 01:30+02:00
  ///     (moving from winter to summer time)
  /// </ul>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hours the hours to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the hours subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusHours(int hours) {
    return _minusHours(
      reference.pointer,
      _id_minusHours as jni$_.JMethodIDPtr,
      hours,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(r'minusMinutes', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusMinutes =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMinutes(long minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of minutes subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one minute will
  /// always be a duration of one minute earlier.
  /// This may cause the local date-time to change by an amount other than one minute.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minutes the minutes to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the minutes subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusMinutes(int minutes) {
    return _minusMinutes(
      reference.pointer,
      _id_minusMinutes as jni$_.JMethodIDPtr,
      minutes,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(r'minusSeconds', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusSeconds(long seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of seconds subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one second will
  /// always be a duration of one second earlier.
  /// This may cause the local date-time to change by an amount other than one second.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param seconds the seconds to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the seconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusSeconds(int seconds) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      seconds,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(r'minusNanos', r'(J)Ljava/time/ZonedDateTime;');

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusNanos(long nanos)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of nanoseconds subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one nano will
  /// always be a duration of one nano earlier.
  /// This may cause the local date-time to change by an amount other than one nano.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanos the nanos to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusNanos(int nanos) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      nanos,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(r'query', r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;');

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this date-time using the specified query.
  ///
  /// This queries this date-time using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(jni$_.JObject? query, {required jni$_.JObjType<$R> R}) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer).object<$R?>(R.nullableType);
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal endExclusive, java.time.temporal.TemporalUnit unit)`
  ///
  /// Calculates the amount of time until another date-time in terms of the specified unit.
  ///
  /// This calculates the amount of time between two {@code ZonedDateTime}
  /// objects in terms of a single {@code TemporalUnit}.
  /// The start and end points are {@code this} and the specified date-time.
  /// The result will be negative if the end is before the start.
  /// For example, the amount in days between two date-times can be calculated
  /// using {@code startDateTime.until(endDateTime, DAYS)}.
  ///
  /// The {@code Temporal} passed to this method is converted to a
  /// {@code ZonedDateTime} using \#from(TemporalAccessor).
  /// If the time-zone differs between the two zoned date-times, the specified
  /// end date-time is normalized to have the same zone as this date-time.
  ///
  /// The calculation returns a whole number, representing the number of
  /// complete units between the two date-times.
  /// For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z
  /// will only be one month as it is one minute short of two months.
  ///
  /// There are two equivalent ways of using this method.
  /// The first is to invoke this method.
  /// The second is to use TemporalUnit\#between(Temporal, Temporal):
  /// <pre>
  ///   // these two lines are equivalent
  ///   amount = start.until(end, MONTHS);
  ///   amount = MONTHS.between(start, end);
  /// </pre>
  /// The choice should be made based on which makes the code more readable.
  ///
  /// The calculation is implemented in this method for ChronoUnit.
  /// The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
  /// {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},
  /// {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},
  /// {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.
  /// Other {@code ChronoUnit} values will throw an exception.
  ///
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line, using the local date-time.
  /// For example, the period from noon on day 1 to noon the following day
  /// in days will always be counted as exactly one day, irrespective of whether
  /// there was a daylight savings change or not.
  ///
  /// Time units operate on the instant time-line.
  /// The calculation effectively converts both zoned date-times to instants
  /// and then calculates the period between the instants.
  /// For example, the period from noon on day 1 to noon the following day
  /// in hours may be 23, 24 or 25 hours (or some other amount) depending on
  /// whether there was a daylight savings change or not.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
  /// passing {@code this} as the first argument and the converted input temporal
  /// as the second argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param endExclusive the end date, exclusive, which is converted to a {@code ZonedDateTime}, not null
  ///@param unit the unit to measure the amount in, not null
  ///@return the amount of time between this date-time and the end date-time
  ///@throws DateTimeException if the amount cannot be calculated, or the end
  ///  temporal cannot be converted to a {@code ZonedDateTime}
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int until(jni$_.JObject? endExclusive, jni$_.JObject? unit) {
    final _$endExclusive = endExclusive?.reference ?? jni$_.jNullReference;
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr, _$endExclusive.pointer, _$unit.pointer).long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter formatter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Formats this date-time using the specified formatter.
  ///
  /// This date-time will be passed to the formatter to produce a string.
  ///@param formatter the formatter to use, not null
  ///@return the formatted date-time string, not null
  ///@throws DateTimeException if an error occurs during printing
  jni$_.JString? format(DateTimeFormatter? formatter) {
    final _$formatter = formatter?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$formatter.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toOffsetDateTime = _class.instanceMethodId(r'toOffsetDateTime', r'()Ljava/time/OffsetDateTime;');

  static final _toOffsetDateTime =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.OffsetDateTime toOffsetDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Converts this date-time to an {@code OffsetDateTime}.
  ///
  /// This creates an offset date-time using the local date-time and offset.
  /// The zone ID is ignored.
  ///@return an offset date-time representing the same local date-time and offset, not null
  jni$_.JObject? toOffsetDateTime() {
    return _toOffsetDateTime(
      reference.pointer,
      _id_toOffsetDateTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_equals = _class.instanceMethodId(r'equals', r'(Ljava/lang/Object;)Z');

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this date-time is equal to another date-time.
  ///
  /// The comparison is based on the offset date-time and the zone.
  /// Only objects of type {@code ZonedDateTime} are compared, other types return false.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other date-time
  bool equals(jni$_.JObject? obj) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this date-time.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this date-time as a {@code String}, such as
  /// {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.
  ///
  /// The format consists of the {@code LocalDateTime} followed by the {@code ZoneOffset}.
  /// If the {@code ZoneId} is not the same as the offset, then the ID is output.
  /// The output is compatible with ISO-8601 if the offset and ID are the same.
  ///@return a string representation of this date-time, not null
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZonedDateTime$NullableType extends jni$_.JObjType<ZonedDateTime?> {
  @jni$_.internal
  const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$NullableType) && other is $ZonedDateTime$NullableType;
  }
}

final class $ZonedDateTime$Type extends jni$_.JObjType<ZonedDateTime> {
  @jni$_.internal
  const $ZonedDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime fromReference(jni$_.JReference reference) => ZonedDateTime.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$Type) && other is $ZonedDateTime$Type;
  }
}

/// from: `java.time.ZoneOffset`
///
/// A time-zone offset from Greenwich/UTC, such as {@code +02:00}.
///
/// A time-zone offset is the amount of time that a time-zone differs from Greenwich/UTC.
/// This is usually a fixed number of hours and minutes.
///
/// Different parts of the world have different time-zone offsets.
/// The rules for how offsets vary by place and time of year are captured in the
/// ZoneId class.
///
/// For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours
/// ahead in summer. The {@code ZoneId} instance for Paris will reference two
/// {@code ZoneOffset} instances - a {@code +01:00} instance for winter,
/// and a {@code +02:00} instance for summer.
///
/// In 2008, time-zone offsets around the world extended from -12:00 to +14:00.
/// To prevent any problems with that range being extended, yet still provide
/// validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.
///
/// This class is designed for use with the ISO calendar system.
/// The fields of hours, minutes and seconds make assumptions that are valid for the
/// standard ISO definitions of those fields. This class may be used with other
/// calendar systems providing the definition of the time fields matches those
/// of the ISO calendar system.
///
/// Instances of {@code ZoneOffset} must be compared using \#equals.
/// Implementations may choose to cache certain common offsets, however
/// applications must not rely on such caching.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZoneOffset} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class ZoneOffset extends ZoneId {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneOffset> $type;

  @jni$_.internal
  ZoneOffset.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneOffset');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneOffset$NullableType();
  static const type = $ZoneOffset$Type();
  static final _id_UTC = _class.staticFieldId(r'UTC', r'Ljava/time/ZoneOffset;');

  /// from: `static public final java.time.ZoneOffset UTC`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The time-zone offset for UTC, with an ID of 'Z'.
  static ZoneOffset? get UTC => _id_UTC.get(_class, const $ZoneOffset$NullableType());

  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/ZoneOffset;');

  /// from: `static public final java.time.ZoneOffset MIN`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the minimum supported offset.
  static ZoneOffset? get MIN => _id_MIN.get(_class, const $ZoneOffset$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/ZoneOffset;');

  /// from: `static public final java.time.ZoneOffset MAX`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the maximum supported offset.
  static ZoneOffset? get MAX => _id_MAX.get(_class, const $ZoneOffset$NullableType());

  static final _id_of$2 = _class.staticMethodId(r'of', r'(Ljava/lang/String;)Ljava/time/ZoneOffset;');

  static final _of$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZoneOffset of(java.lang.String offsetId)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using the ID.
  ///
  /// This method parses the string ID of a {@code ZoneOffset} to
  /// return an instance. The parsing accepts all the formats generated by
  /// \#getId(), plus some additional formats:
  /// <ul>
  /// <li>{@code Z} - for UTC
  /// <li>{@code +h}
  /// <li>{@code +hh}
  /// <li>{@code +hh:mm}
  /// <li>{@code -hh:mm}
  /// <li>{@code +hhmm}
  /// <li>{@code -hhmm}
  /// <li>{@code +hh:mm:ss}
  /// <li>{@code -hh:mm:ss}
  /// <li>{@code +hhmmss}
  /// <li>{@code -hhmmss}
  /// </ul>
  /// Note that &plusmn; means either the plus or minus symbol.
  ///
  /// The ID of the returned offset will be normalized to one of the formats
  /// described by \#getId().
  ///
  /// The maximum supported range is from +18:00 to -18:00 inclusive.
  ///@param offsetId the offset ID, not null
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset ID is invalid
  static ZoneOffset? of$2(jni$_.JString? offsetId) {
    final _$offsetId = offsetId?.reference ?? jni$_.jNullReference;
    return _of$2(
      _class.reference.pointer,
      _id_of$2 as jni$_.JMethodIDPtr,
      _$offsetId.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(r'ofHours', r'(I)Ljava/time/ZoneOffset;');

  static final _ofHours =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofHours(int hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in hours.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHours(int hours) {
    return _ofHours(
      _class.reference.pointer,
      _id_ofHours as jni$_.JMethodIDPtr,
      hours,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutes = _class.staticMethodId(r'ofHoursMinutes', r'(II)Ljava/time/ZoneOffset;');

  static final _ofHoursMinutes =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
            jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>,
          )
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutes(int hours, int minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in
  /// hours and minutes.
  ///
  /// The sign of the hours and minutes components must match.
  /// Thus, if the hours is negative, the minutes must be negative or zero.
  /// If the hours is zero, the minutes may be positive, negative or zero.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@param minutes the time-zone offset in minutes, from 0 to &plusmn;59, sign matches hours
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHoursMinutes(int hours, int minutes) {
    return _ofHoursMinutes(
      _class.reference.pointer,
      _id_ofHoursMinutes as jni$_.JMethodIDPtr,
      hours,
      minutes,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutesSeconds = _class.staticMethodId(
    r'ofHoursMinutesSeconds',
    r'(III)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutesSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
            jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
          )
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutesSeconds(int hours, int minutes, int seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in
  /// hours, minutes and seconds.
  ///
  /// The sign of the hours, minutes and seconds components must match.
  /// Thus, if the hours is negative, the minutes and seconds must be negative or zero.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@param minutes the time-zone offset in minutes, from 0 to &plusmn;59, sign matches hours and seconds
  ///@param seconds the time-zone offset in seconds, from 0 to &plusmn;59, sign matches hours and minutes
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHoursMinutesSeconds(int hours, int minutes, int seconds) {
    return _ofHoursMinutesSeconds(
      _class.reference.pointer,
      _id_ofHoursMinutesSeconds as jni$_.JMethodIDPtr,
      hours,
      minutes,
      seconds,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_from$1 = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneOffset;',
  );

  static final _from$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.ZoneOffset from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} from a temporal object.
  ///
  /// This obtains an offset based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZoneOffset}.
  ///
  /// A {@code TemporalAccessor} represents some form of date and time information.
  /// This factory converts the arbitrary temporal object to an instance of {@code ZoneOffset}.
  ///
  /// The conversion uses the TemporalQueries\#offset() query, which relies
  /// on extracting the ChronoField\#OFFSET_SECONDS OFFSET_SECONDS field.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZoneOffset::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zone-offset, not null
  ///@throws DateTimeException if unable to convert to an {@code ZoneOffset}
  static ZoneOffset? from$1(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from$1(
      _class.reference.pointer,
      _id_from$1 as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofTotalSeconds = _class.staticMethodId(r'ofTotalSeconds', r'(I)Ljava/time/ZoneOffset;');

  static final _ofTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofTotalSeconds(int totalSeconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} specifying the total offset in seconds
  ///
  /// The offset must be in the range {@code -18:00} to {@code +18:00}, which corresponds to -64800 to +64800.
  ///@param totalSeconds the total time-zone offset in seconds, from -64800 to +64800
  ///@return the ZoneOffset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofTotalSeconds(int totalSeconds) {
    return _ofTotalSeconds(
      _class.reference.pointer,
      _id_ofTotalSeconds as jni$_.JMethodIDPtr,
      totalSeconds,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getTotalSeconds = _class.instanceMethodId(r'getTotalSeconds', r'()I');

  static final _getTotalSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getTotalSeconds()`
  ///
  /// Gets the total zone offset in seconds.
  ///
  /// This is the primary way to access the offset amount.
  /// It returns the total of the hours, minutes and seconds fields as a
  /// single offset that can be added to a time.
  ///@return the total zone offset amount in seconds
  int getTotalSeconds() {
    return _getTotalSeconds(reference.pointer, _id_getTotalSeconds as jni$_.JMethodIDPtr).integer;
  }

  static final _id_getId = _class.instanceMethodId(r'getId', r'()Ljava/lang/String;');

  static final _getId =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the normalized zone offset ID.
  ///
  /// The ID is minor variation to the standard ISO-8601 formatted string
  /// for the offset. There are three formats:
  /// <ul>
  /// <li>{@code Z} - for UTC (ISO-8601)
  /// <li>{@code +hh:mm} or {@code -hh:mm} - if the seconds are zero (ISO-8601)
  /// <li>{@code +hh:mm:ss} or {@code -hh:mm:ss} - if the seconds are non-zero (not ISO-8601)
  /// </ul>
  ///@return the zone offset ID, not null
  jni$_.JString? getId() {
    return _getId(
      reference.pointer,
      _id_getId as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(r'getRules', r'()Ljava/time/zone/ZoneRules;');

  static final _getRules =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the associated time-zone rules.
  ///
  /// The rules will always return this offset when queried.
  /// The implementation class is immutable, thread-safe and serializable.
  ///@return the rules, not null
  ZoneRules? getRules() {
    return _getRules(
      reference.pointer,
      _id_getRules as jni$_.JMethodIDPtr,
    ).object<ZoneRules?>(const $ZoneRules$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(r'isSupported', r'(Ljava/time/temporal/TemporalField;)Z');

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this offset can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range and
  /// \#get(TemporalField) get methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns true.
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this offset, false if not
  bool isSupported(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer, _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This offset is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$field.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(r'get', r'(Ljava/time/temporal/TemporalField;)I');

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this offset as an {@code int}.
  ///
  /// This queries this offset for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns the value of the offset.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer).integer;
  }

  static final _id_getLong = _class.instanceMethodId(r'getLong', r'(Ljava/time/temporal/TemporalField;)J');

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this offset as a {@code long}.
  ///
  /// This queries this offset for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns the value of the offset.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr, _$field.pointer).long;
  }

  static final _id_query = _class.instanceMethodId(r'query', r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;');

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this offset using the specified query.
  ///
  /// This queries this offset using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(jni$_.JObject? query, {required jni$_.JObjType<$R> R}) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adjusts the specified temporal object to have the same offset as this object.
  ///
  /// This returns a temporal object of the same observable type as the input
  /// with the offset changed to be the same as this.
  ///
  /// The adjustment is equivalent to using Temporal\#with(TemporalField, long)
  /// passing ChronoField\#OFFSET_SECONDS as the field.
  ///
  /// In most cases, it is clearer to reverse the calling pattern by using
  /// Temporal\#with(TemporalAdjuster):
  /// <pre>
  ///   // these two lines are equivalent, but the second approach is recommended
  ///   temporal = thisOffset.adjustInto(temporal);
  ///   temporal = temporal.with(thisOffset);
  /// </pre>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param temporal the target object to be adjusted, not null
  ///@return the adjusted object, not null
  ///@throws DateTimeException if unable to make the adjustment
  ///@throws ArithmeticException if numeric overflow occurs
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(r'compareTo', r'(Ljava/time/ZoneOffset;)I');

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public int compareTo(java.time.ZoneOffset other)`
  ///
  /// Compares this offset to another offset in descending order.
  ///
  /// The offsets are compared in the order that they occur for the same time
  /// of day around the world. Thus, an offset of {@code +10:00} comes before an
  /// offset of {@code +09:00} and so on down to {@code -18:00}.
  ///
  /// The comparison is "consistent with equals", as defined by Comparable.
  ///@param other the other date to compare to, not null
  ///@return the comparator value, negative if less, positive if greater
  ///@throws NullPointerException if {@code other} is null
  int compareTo(ZoneOffset? other) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr, _$other.pointer).integer;
  }

  static final _id_equals = _class.instanceMethodId(r'equals', r'(Ljava/lang/Object;)Z');

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this offset is equal to another offset.
  ///
  /// The comparison is based on the amount of the offset in seconds.
  /// This is equivalent to a comparison by ID.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other offset
  bool equals(jni$_.JObject? obj) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer).boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this offset.
  ///@return a suitable hash code
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this offset as a {@code String}, using the normalized ID.
  ///@return a string representation of this offset, not null
  jni$_.JString? toString1() {
    return _toString1(
      reference.pointer,
      _id_toString1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneOffset$NullableType extends jni$_.JObjType<ZoneOffset?> {
  @jni$_.internal
  const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$NullableType) && other is $ZoneOffset$NullableType;
  }
}

final class $ZoneOffset$Type extends jni$_.JObjType<ZoneOffset> {
  @jni$_.internal
  const $ZoneOffset$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset fromReference(jni$_.JReference reference) => ZoneOffset.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$Type) && other is $ZoneOffset$Type;
  }
}

/// from: `java.time.Instant`
///
/// An instantaneous point on the time-line.
///
/// This class models a single instantaneous point on the time-line.
/// This might be used to record event time-stamps in the application.
///
/// The range of an instant requires the storage of a number larger than a {@code long}.
/// To achieve this, the class stores a {@code long} representing epoch-seconds and an
/// {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
/// The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
/// where instants after the epoch have positive values, and earlier instants have negative values.
/// For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
/// than a smaller value.
///
/// <h3>Time-scale</h3>
///
/// The length of the solar day is the standard way that humans measure time.
/// This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
/// forming a 86400 second day.
///
/// Modern timekeeping is based on atomic clocks which precisely define an SI second
/// relative to the transitions of a Caesium atom. The length of an SI second was defined
/// to be very close to the 86400th fraction of a day.
///
/// Unfortunately, as the Earth rotates the length of the day varies.
/// In addition, over time the average length of the day is getting longer as the Earth slows.
/// As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
/// The actual length of any given day and the amount by which the Earth is slowing
/// are not predictable and can only be determined by measurement.
/// The UT1 time-scale captures the accurate length of day, but is only available some
/// time after the day has completed.
///
/// The UTC time-scale is a standard approach to bundle up all the additional fractions
/// of a second from UT1 into whole seconds, known as <i>leap-seconds</i>.
/// A leap-second may be added or removed depending on the Earth's rotational changes.
/// As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where
/// necessary in order to keep the day aligned with the Sun.
///
/// The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
/// Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
/// alterations to the length of the notional second. As of 2012, discussions are underway
/// to change the definition of UTC again, with the potential to remove leap seconds or
/// introduce other changes.
///
/// Given the complexity of accurate timekeeping described above, this Java API defines
/// its own time-scale, the <i>Java Time-Scale</i>.
///
/// The Java Time-Scale divides each calendar day into exactly 86400
/// subdivisions, known as seconds.  These seconds may differ from the
/// SI second.  It closely matches the de facto international civil time
/// scale, the definition of which changes from time to time.
///
/// The Java Time-Scale has slightly different definitions for different
/// segments of the time-line, each based on the consensus international
/// time scale that is used as the basis for civil time. Whenever the
/// internationally-agreed time scale is modified or replaced, a new
/// segment of the Java Time-Scale must be defined for it.  Each segment
/// must meet these requirements:
/// <ul>
/// <li>the Java Time-Scale shall closely match the underlying international
///  civil time scale;</li>
/// <li>the Java Time-Scale shall exactly match the international civil
///  time scale at noon each day;</li>
/// <li>the Java Time-Scale shall have a precisely-defined relationship to
///  the international civil time scale.</li>
/// </ul>
/// There are currently, as of 2013, two segments in the Java time-scale.
///
/// For the segment from 1972-11-03 (exact boundary discussed below) until
/// further notice, the consensus international time scale is UTC (with
/// leap seconds).  In this segment, the Java Time-Scale is identical to
/// <a href="http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/">UTC-SLS</a>.
/// This is identical to UTC on days that do not have a leap second.
/// On days that do have a leap second, the leap second is spread equally
/// over the last 1000 seconds of the day, maintaining the appearance of
/// exactly 86400 seconds per day.
///
/// For the segment prior to 1972-11-03, extending back arbitrarily far,
/// the consensus international time scale is defined to be UT1, applied
/// proleptically, which is equivalent to the (mean) solar time on the
/// prime meridian (Greenwich). In this segment, the Java Time-Scale is
/// identical to the consensus international time scale. The exact
/// boundary between the two segments is the instant where UT1 = UTC
/// between 1972-11-03T00:00 and 1972-11-04T12:00.
///
/// Implementations of the Java time-scale using the JSR-310 API are not
/// required to provide any clock that is sub-second accurate, or that
/// progresses monotonically or smoothly. Implementations are therefore
/// not required to actually perform the UTC-SLS slew or to otherwise be
/// aware of leap seconds. JSR-310 does, however, require that
/// implementations must document the approach they use when defining a
/// clock representing the current instant.
/// See Clock for details on the available clocks.
///
/// The Java time-scale is used for all date-time classes.
/// This includes {@code Instant}, {@code LocalDate}, {@code LocalTime}, {@code OffsetDateTime},
/// {@code ZonedDateTime} and {@code Duration}.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code Instant} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(r'EPOCH', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the 1970-01-01T00:00:00Z epoch instant.
  static Instant? get EPOCH => _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(r'MIN', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The minimum supported {@code Instant}, '-1000000000-01-01T00:00Z'.
  /// This could be used by an application as a "far past" instant.
  ///
  /// This is one year earlier than the minimum {@code LocalDateTime}.
  /// This provides sufficient values to handle the range of {@code ZoneOffset}
  /// which affect the instant in addition to the local date-time.
  /// The value is also chosen such that the value of the year fits in
  /// an {@code int}.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(r'MAX', r'Ljava/time/Instant;');

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The maximum supported {@code Instant}, '1000000000-12-31T23:59:59.999999999Z'.
  /// This could be used by an application as a "far future" instant.
  ///
  /// This is one year later than the maximum {@code LocalDateTime}.
  /// This provides sufficient values to handle the range of {@code ZoneOffset}
  /// which affect the instant in addition to the local date-time.
  /// The value is also chosen such that the value of the year fits in
  /// an {@code int}.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_now = _class.staticMethodId(r'now', r'()Ljava/time/Instant;');

  static final _now =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current instant from the system clock.
  ///
  /// This will query the Clock\#systemUTC() system UTC clock to
  /// obtain the current instant.
  ///
  /// Using this method will prevent the ability to use an alternate time-source for
  /// testing because the clock is effectively hard-coded.
  ///@return the current instant using the system clock, not null
  static Instant? now() {
    return _now(
      _class.reference.pointer,
      _id_now as jni$_.JMethodIDPtr,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(r'now', r'(Ljava/time/Clock;)Ljava/time/Instant;');

  static final _now$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current instant from the specified clock.
  ///
  /// This will query the specified clock to obtain the current time.
  ///
  /// Using this method allows the use of an alternate clock for testing.
  /// The alternate clock may be introduced using Clock dependency injection.
  ///@param clock the clock to use, not null
  ///@return the current instant, not null
  static Instant? now$1(jni$_.JObject? clock) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(
      _class.reference.pointer,
      _id_now$1 as jni$_.JMethodIDPtr,
      _$clock.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(r'ofEpochSecond', r'(J)Ljava/time/Instant;');

  static final _ofEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long epochSecond)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using seconds from the
  /// epoch of 1970-01-01T00:00:00Z.
  ///
  /// The nanosecond field is set to zero.
  ///@param epochSecond the number of seconds from 1970-01-01T00:00:00Z
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  static Instant? ofEpochSecond(int epochSecond) {
    return _ofEpochSecond(
      _class.reference.pointer,
      _id_ofEpochSecond as jni$_.JMethodIDPtr,
      epochSecond,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond$1 = _class.staticMethodId(r'ofEpochSecond', r'(JJ)Ljava/time/Instant;');

  static final _ofEpochSecond$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
            jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>,
          )
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long epochSecond, long nanoAdjustment)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using seconds from the
  /// epoch of 1970-01-01T00:00:00Z and nanosecond fraction of second.
  ///
  /// This method allows an arbitrary number of nanoseconds to be passed in.
  /// The factory will alter the values of the second and nanosecond in order
  /// to ensure that the stored nanosecond is in the range 0 to 999,999,999.
  /// For example, the following will result in exactly the same instant:
  /// <pre>
  ///  Instant.ofEpochSecond(3, 1);
  ///  Instant.ofEpochSecond(4, -999_999_999);
  ///  Instant.ofEpochSecond(2, 1000_000_001);
  /// </pre>
  ///@param epochSecond the number of seconds from 1970-01-01T00:00:00Z
  ///@param nanoAdjustment the nanosecond adjustment to the number of seconds, positive or negative
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  static Instant? ofEpochSecond$1(int epochSecond, int nanoAdjustment) {
    return _ofEpochSecond$1(
      _class.reference.pointer,
      _id_ofEpochSecond$1 as jni$_.JMethodIDPtr,
      epochSecond,
      nanoAdjustment,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochMilli = _class.staticMethodId(r'ofEpochMilli', r'(J)Ljava/time/Instant;');

  static final _ofEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochMilli(long epochMilli)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using milliseconds from the
  /// epoch of 1970-01-01T00:00:00Z.
  ///
  /// The seconds and nanoseconds are extracted from the specified milliseconds.
  ///@param epochMilli the number of milliseconds from 1970-01-01T00:00:00Z
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  static Instant? ofEpochMilli(int epochMilli) {
    return _ofEpochMilli(
      _class.reference.pointer,
      _id_ofEpochMilli as jni$_.JMethodIDPtr,
      epochMilli,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_from = _class.staticMethodId(r'from', r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;');

  static final _from =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} from a temporal object.
  ///
  /// This obtains an instant based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code Instant}.
  ///
  /// The conversion extracts the ChronoField\#INSTANT_SECONDS INSTANT_SECONDS
  /// and ChronoField\#NANO_OF_SECOND NANO_OF_SECOND fields.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code Instant::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the instant, not null
  ///@throws DateTimeException if unable to convert to an {@code Instant}
  static Instant? from(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(
      _class.reference.pointer,
      _id_from as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(r'parse', r'(Ljava/lang/CharSequence;)Ljava/time/Instant;');

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} from a text string such as
  /// {@code 2007-12-03T10:15:30.00Z}.
  ///
  /// The string must represent a valid instant in UTC and is parsed using
  /// DateTimeFormatter\#ISO_INSTANT.
  ///@param text the text to parse, not null
  ///@return the parsed instant, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static Instant? parse(jni$_.JObject? text) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(r'isSupported', r'(Ljava/time/temporal/TemporalField;)Z');

  static final _isSupported =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this instant can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range,
  /// \#get(TemporalField) get and \#with(TemporalField, long)
  /// methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The supported fields are:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND}
  /// <li>{@code MICRO_OF_SECOND}
  /// <li>{@code MILLI_OF_SECOND}
  /// <li>{@code INSTANT_SECONDS}
  /// </ul>
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this instant, false if not
  bool isSupported(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer, _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer).boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(r'isSupported', r'(Ljava/time/temporal/TemporalUnit;)Z');

  static final _isSupported$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit unit)`
  ///
  /// Checks if the specified unit is supported.
  ///
  /// This checks if the specified unit can be added to, or subtracted from, this date-time.
  /// If false, then calling the \#plus(long, TemporalUnit) and
  /// \#minus(long, TemporalUnit) minus methods will throw an exception.
  ///
  /// If the unit is a ChronoUnit then the query is implemented here.
  /// The supported units are:
  /// <ul>
  /// <li>{@code NANOS}
  /// <li>{@code MICROS}
  /// <li>{@code MILLIS}
  /// <li>{@code SECONDS}
  /// <li>{@code MINUTES}
  /// <li>{@code HOURS}
  /// <li>{@code HALF_DAYS}
  /// <li>{@code DAYS}
  /// </ul>
  /// All other {@code ChronoUnit} instances will return false.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
  /// passing {@code this} as the argument.
  /// Whether the unit is supported is determined by the unit.
  ///@param unit the unit to check, null returns false
  ///@return true if the unit can be added/subtracted, false if not
  bool isSupported$1(jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer, _id_isSupported$1 as jni$_.JMethodIDPtr, _$unit.pointer).boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This instant is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
      reference.pointer,
      _id_range as jni$_.JMethodIDPtr,
      _$field.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(r'get', r'(Ljava/time/temporal/TemporalField;)I');

  static final _get =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this instant as an {@code int}.
  ///
  /// This queries this instant for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time, except {@code INSTANT_SECONDS} which is too
  /// large to fit in an {@code int} and throws a {@code DateTimeException}.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer).integer;
  }

  static final _id_getLong = _class.instanceMethodId(r'getLong', r'(Ljava/time/temporal/TemporalField;)J');

  static final _getLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this instant as a {@code long}.
  ///
  /// This queries this instant for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(jni$_.JObject? field) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr, _$field.pointer).long;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(r'getEpochSecond', r'()J');

  static final _getEpochSecond =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallLongMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public long getEpochSecond()`
  ///
  /// Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.
  ///
  /// The epoch second count is a simple incrementing count of seconds where
  /// second 0 is 1970-01-01T00:00:00Z.
  /// The nanosecond part is returned by \#getNano.
  ///@return the seconds from the epoch of 1970-01-01T00:00:00Z
  int getEpochSecond() {
    return _getEpochSecond(reference.pointer, _id_getEpochSecond as jni$_.JMethodIDPtr).long;
  }

  static final _id_getNano = _class.instanceMethodId(r'getNano', r'()I');

  static final _getNano =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int getNano()`
  ///
  /// Gets the number of nanoseconds, later along the time-line, from the start
  /// of the second.
  ///
  /// The nanosecond-of-second value measures the total number of nanoseconds from
  /// the second returned by \#getEpochSecond.
  ///@return the nanoseconds within the second, always positive, never exceeds 999,999,999
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr).integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster adjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an adjusted copy of this instant.
  ///
  /// This returns an {@code Instant}, based on this one, with the instant adjusted.
  /// The adjustment takes place using the specified adjuster strategy object.
  /// Read the documentation of the adjuster to understand what adjustment will be made.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalAdjuster\#adjustInto(Temporal) method on the
  /// specified adjuster passing {@code this} as the argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param adjuster the adjuster to use, not null
  ///@return an {@code Instant} based on {@code this} with the adjustment made, not null
  ///@throws DateTimeException if the adjustment cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? with$(jni$_.JObject? adjuster) {
    final _$adjuster = adjuster?.reference ?? jni$_.jNullReference;
    return _with$(
      reference.pointer,
      _id_with$ as jni$_.JMethodIDPtr,
      _$adjuster.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)
          >();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField field, long newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified field set to a new value.
  ///
  /// This returns an {@code Instant}, based on this one, with the value
  /// for the specified field changed.
  /// If it is not possible to set the value, because the field is not supported or for
  /// some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the adjustment is implemented here.
  /// The supported fields behave as follows:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND} -
  ///  Returns an {@code Instant} with the specified nano-of-second.
  ///  The epoch-second will be unchanged.
  /// <li>{@code MICRO_OF_SECOND} -
  ///  Returns an {@code Instant} with the nano-of-second replaced by the specified
  ///  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.
  /// <li>{@code MILLI_OF_SECOND} -
  ///  Returns an {@code Instant} with the nano-of-second replaced by the specified
  ///  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.
  /// <li>{@code INSTANT_SECONDS} -
  ///  Returns an {@code Instant} with the specified epoch-second.
  ///  The nano-of-second will be unchanged.
  /// </ul>
  ///
  /// In all cases, if the new value is outside the valid range of values for the field
  /// then a {@code DateTimeException} will be thrown.
  ///
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the field determines
  /// whether and how to adjust the instant.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param field the field to set in the result, not null
  ///@param newValue the new value of the field in the result
  ///@return an {@code Instant} based on {@code this} with the specified field set, not null
  ///@throws DateTimeException if the field cannot be set
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? with$1(jni$_.JObject? field, int newValue) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _with$1(
      reference.pointer,
      _id_with$1 as jni$_.JMethodIDPtr,
      _$field.pointer,
      newValue,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code Instant} truncated to the specified unit.
  ///
  /// Truncating the instant returns a copy of the original with fields
  /// smaller than the specified unit set to zero.
  /// The fields are calculated on the basis of using a UTC offset as seen
  /// in {@code toString}.
  /// For example, truncating with the ChronoUnit\#MINUTES MINUTES unit will
  /// round down to the nearest minute, setting the seconds and nanoseconds to zero.
  ///
  /// The unit must have a {@linkplain TemporalUnit\#getDuration() duration}
  /// that divides into the length of a standard day without remainder.
  /// This includes all supplied time units on ChronoUnit and
  /// ChronoUnit\#DAYS DAYS. Other units throw an exception.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param unit the unit to truncate to, not null
  ///@return an {@code Instant} based on this instant with the time truncated, not null
  ///@throws DateTimeException if the unit is invalid for truncation
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  Instant? truncatedTo(jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(
      reference.pointer,
      _id_truncatedTo as jni$_.JMethodIDPtr,
      _$unit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(r'plus', r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;');

  static final _plus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount amountToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount added.
  ///
  /// This returns an {@code Instant}, based on this one, with the specified amount added.
  /// The amount is typically Duration but may be any other type implementing
  /// the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#addTo(Temporal). The amount implementation is free
  /// to implement the addition in any way it wishes, however it typically
  /// calls back to \#plus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount to add, not null
  ///@return an {@code Instant} based on this instant with the addition made, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plus(jni$_.JObject? amountToAdd) {
    final _$amountToAdd = amountToAdd?.reference ?? jni$_.jNullReference;
    return _plus(
      reference.pointer,
      _id_plus as jni$_.JMethodIDPtr,
      _$amountToAdd.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant plus(long amountToAdd, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount added.
  ///
  /// This returns an {@code Instant}, based on this one, with the amount
  /// in terms of the unit added. If it is not possible to add the amount, because the
  /// unit is not supported or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoUnit then the addition is implemented here.
  /// The supported fields behave as follows:
  /// <ul>
  /// <li>{@code NANOS} -
  ///  Returns an {@code Instant} with the specified number of nanoseconds added.
  ///  This is equivalent to \#plusNanos(long).
  /// <li>{@code MICROS} -
  ///  Returns an {@code Instant} with the specified number of microseconds added.
  ///  This is equivalent to \#plusNanos(long) with the amount
  ///  multiplied by 1,000.
  /// <li>{@code MILLIS} -
  ///  Returns an {@code Instant} with the specified number of milliseconds added.
  ///  This is equivalent to \#plusNanos(long) with the amount
  ///  multiplied by 1,000,000.
  /// <li>{@code SECONDS} -
  ///  Returns an {@code Instant} with the specified number of seconds added.
  ///  This is equivalent to \#plusSeconds(long).
  /// <li>{@code MINUTES} -
  ///  Returns an {@code Instant} with the specified number of minutes added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 60.
  /// <li>{@code HOURS} -
  ///  Returns an {@code Instant} with the specified number of hours added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 3,600.
  /// <li>{@code HALF_DAYS} -
  ///  Returns an {@code Instant} with the specified number of half-days added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 43,200 (12 hours).
  /// <li>{@code DAYS} -
  ///  Returns an {@code Instant} with the specified number of days added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 86,400 (24 hours).
  /// </ul>
  ///
  /// All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the unit determines
  /// whether and how to perform the addition.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount of the unit to add to the result, may be negative
  ///@param unit the unit of the amount to add, not null
  ///@return an {@code Instant} based on this instant with the specified amount added, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plus$1(int amountToAdd, jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _plus$1(
      reference.pointer,
      _id_plus$1 as jni$_.JMethodIDPtr,
      amountToAdd,
      _$unit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(r'plusSeconds', r'(J)Ljava/time/Instant;');

  static final _plusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusSeconds(long secondsToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in seconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param secondsToAdd the seconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified seconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusSeconds(int secondsToAdd) {
    return _plusSeconds(
      reference.pointer,
      _id_plusSeconds as jni$_.JMethodIDPtr,
      secondsToAdd,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(r'plusMillis', r'(J)Ljava/time/Instant;');

  static final _plusMillis =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusMillis(long millisToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in milliseconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param millisToAdd the milliseconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified milliseconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusMillis(int millisToAdd) {
    return _plusMillis(
      reference.pointer,
      _id_plusMillis as jni$_.JMethodIDPtr,
      millisToAdd,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(r'plusNanos', r'(J)Ljava/time/Instant;');

  static final _plusNanos =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusNanos(long nanosToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in nanoseconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanosToAdd the nanoseconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified nanoseconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusNanos(int nanosToAdd) {
    return _plusNanos(
      reference.pointer,
      _id_plusNanos as jni$_.JMethodIDPtr,
      nanosToAdd,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount amountToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount subtracted.
  ///
  /// This returns an {@code Instant}, based on this one, with the specified amount subtracted.
  /// The amount is typically Duration but may be any other type implementing
  /// the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#subtractFrom(Temporal). The amount implementation is free
  /// to implement the subtraction in any way it wishes, however it typically
  /// calls back to \#minus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount to subtract, not null
  ///@return an {@code Instant} based on this instant with the subtraction made, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minus(jni$_.JObject? amountToSubtract) {
    final _$amountToSubtract = amountToSubtract?.reference ?? jni$_.jNullReference;
    return _minus(
      reference.pointer,
      _id_minus as jni$_.JMethodIDPtr,
      _$amountToSubtract.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Instant minus(long amountToSubtract, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount subtracted.
  ///
  /// This returns an {@code Instant}, based on this one, with the amount
  /// in terms of the unit subtracted. If it is not possible to subtract the amount,
  /// because the unit is not supported or for some other reason, an exception is thrown.
  ///
  /// This method is equivalent to \#plus(long, TemporalUnit) with the amount negated.
  /// See that method for a full description of how addition, and thus subtraction, works.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount of the unit to subtract from the result, may be negative
  ///@param unit the unit of the amount to subtract, not null
  ///@return an {@code Instant} based on this instant with the specified amount subtracted, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minus$1(int amountToSubtract, jni$_.JObject? unit) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _minus$1(
      reference.pointer,
      _id_minus$1 as jni$_.JMethodIDPtr,
      amountToSubtract,
      _$unit.pointer,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(r'minusSeconds', r'(J)Ljava/time/Instant;');

  static final _minusSeconds =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusSeconds(long secondsToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in seconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param secondsToSubtract the seconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified seconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusSeconds(int secondsToSubtract) {
    return _minusSeconds(
      reference.pointer,
      _id_minusSeconds as jni$_.JMethodIDPtr,
      secondsToSubtract,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(r'minusMillis', r'(J)Ljava/time/Instant;');

  static final _minusMillis =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusMillis(long millisToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in milliseconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param millisToSubtract the milliseconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified milliseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusMillis(int millisToSubtract) {
    return _minusMillis(
      reference.pointer,
      _id_minusMillis as jni$_.JMethodIDPtr,
      millisToSubtract,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(r'minusNanos', r'(J)Ljava/time/Instant;');

  static final _minusNanos =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)
        >
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusNanos(long nanosToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in nanoseconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanosToSubtract the nanoseconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified nanoseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusNanos(int nanosToSubtract) {
    return _minusNanos(
      reference.pointer,
      _id_minusNanos as jni$_.JMethodIDPtr,
      nanosToSubtract,
    ).object<Instant?>(const $Instant$NullableType());
  }

  static final _id_query = _class.instanceMethodId(r'query', r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;');

  static final _query =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this instant using the specified query.
  ///
  /// This queries this instant using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(jni$_.JObject? query, {required jni$_.JObjType<$R> R}) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer).object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adjusts the specified temporal object to have this instant.
  ///
  /// This returns a temporal object of the same observable type as the input
  /// with the instant changed to be the same as this.
  ///
  /// The adjustment is equivalent to using Temporal\#with(TemporalField, long)
  /// twice, passing ChronoField\#INSTANT_SECONDS and
  /// ChronoField\#NANO_OF_SECOND as the fields.
  ///
  /// In most cases, it is clearer to reverse the calling pattern by using
  /// Temporal\#with(TemporalAdjuster):
  /// <pre>
  ///   // these two lines are equivalent, but the second approach is recommended
  ///   temporal = thisInstant.adjustInto(temporal);
  ///   temporal = temporal.with(thisInstant);
  /// </pre>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param temporal the target object to be adjusted, not null
  ///@return the adjusted object, not null
  ///@throws DateTimeException if unable to make the adjustment
  ///@throws ArithmeticException if numeric overflow occurs
  jni$_.JObject? adjustInto(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(
      reference.pointer,
      _id_adjustInto as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public long until(java.time.temporal.Temporal endExclusive, java.time.temporal.TemporalUnit unit)`
  ///
  /// Calculates the amount of time until another instant in terms of the specified unit.
  ///
  /// This calculates the amount of time between two {@code Instant}
  /// objects in terms of a single {@code TemporalUnit}.
  /// The start and end points are {@code this} and the specified instant.
  /// The result will be negative if the end is before the start.
  /// The calculation returns a whole number, representing the number of
  /// complete units between the two instants.
  /// The {@code Temporal} passed to this method is converted to a
  /// {@code Instant} using \#from(TemporalAccessor).
  /// For example, the amount in seconds between two dates can be calculated
  /// using {@code startInstant.until(endInstant, SECONDS)}.
  ///
  /// There are two equivalent ways of using this method.
  /// The first is to invoke this method.
  /// The second is to use TemporalUnit\#between(Temporal, Temporal):
  /// <pre>
  ///   // these two lines are equivalent
  ///   amount = start.until(end, SECONDS);
  ///   amount = SECONDS.between(start, end);
  /// </pre>
  /// The choice should be made based on which makes the code more readable.
  ///
  /// The calculation is implemented in this method for ChronoUnit.
  /// The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
  /// {@code MINUTES}, {@code HOURS}, {@code HALF_DAYS} and {@code DAYS}
  /// are supported. Other {@code ChronoUnit} values will throw an exception.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
  /// passing {@code this} as the first argument and the converted input temporal
  /// as the second argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param endExclusive the end date, exclusive, which is converted to an {@code Instant}, not null
  ///@param unit the unit to measure the amount in, not null
  ///@return the amount of time between this instant and the end instant
  ///@throws DateTimeException if the amount cannot be calculated, or the end
  ///  temporal cannot be converted to an {@code Instant}
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int until(jni$_.JObject? endExclusive, jni$_.JObject? unit) {
    final _$endExclusive = endExclusive?.reference ?? jni$_.jNullReference;
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr, _$endExclusive.pointer, _$unit.pointer).long;
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Combines this instant with an offset to create an {@code OffsetDateTime}.
  ///
  /// This returns an {@code OffsetDateTime} formed from this instant at the
  /// specified offset from UTC/Greenwich. An exception will be thrown if the
  /// instant is too large to fit into an offset date-time.
  ///
  /// This method is equivalent to
  /// OffsetDateTime\#ofInstant(Instant, ZoneId) OffsetDateTime.ofInstant(this, offset).
  ///@param offset the offset to combine with, not null
  ///@return the offset date-time formed from this instant and the specified offset, not null
  ///@throws DateTimeException if the result exceeds the supported range
  jni$_.JObject? atOffset(ZoneOffset? offset) {
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _atOffset(
      reference.pointer,
      _id_atOffset as jni$_.JMethodIDPtr,
      _$offset.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atZone = _class.instanceMethodId(r'atZone', r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;');

  static final _atZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Combines this instant with a time-zone to create a {@code ZonedDateTime}.
  ///
  /// This returns an {@code ZonedDateTime} formed from this instant at the
  /// specified time-zone. An exception will be thrown if the instant is too
  /// large to fit into a zoned date-time.
  ///
  /// This method is equivalent to
  /// ZonedDateTime\#ofInstant(Instant, ZoneId) ZonedDateTime.ofInstant(this, zone).
  ///@param zone the zone to combine with, not null
  ///@return the zoned date-time formed from this instant and the specified zone, not null
  ///@throws DateTimeException if the result exceeds the supported range
  ZonedDateTime? atZone(ZoneId? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _atZone(
      reference.pointer,
      _id_atZone as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(r'toEpochMilli', r'()J');

  static final _toEpochMilli =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallLongMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public long toEpochMilli()`
  ///
  /// Converts this instant to the number of milliseconds from the epoch
  /// of 1970-01-01T00:00:00Z.
  ///
  /// If this instant represents a point on the time-line too far in the future
  /// or past to fit in a {@code long} milliseconds, then an exception is thrown.
  ///
  /// If this instant has greater than millisecond precision, then the conversion
  /// will drop any excess precision information as though the amount in nanoseconds
  /// was subject to integer division by one million.
  ///@return the number of milliseconds since the epoch of 1970-01-01T00:00:00Z
  ///@throws ArithmeticException if numeric overflow occurs
  int toEpochMilli() {
    return _toEpochMilli(reference.pointer, _id_toEpochMilli as jni$_.JMethodIDPtr).long;
  }

  static final _id_compareTo = _class.instanceMethodId(r'compareTo', r'(Ljava/time/Instant;)I');

  static final _compareTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public int compareTo(java.time.Instant otherInstant)`
  ///
  /// Compares this instant to the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  /// It is "consistent with equals", as defined by Comparable.
  ///@param otherInstant the other instant to compare to, not null
  ///@return the comparator value, negative if less, positive if greater
  ///@throws NullPointerException if otherInstant is null
  int compareTo(Instant? otherInstant) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr, _$otherInstant.pointer).integer;
  }

  static final _id_isAfter = _class.instanceMethodId(r'isAfter', r'(Ljava/time/Instant;)Z');

  static final _isAfter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isAfter(java.time.Instant otherInstant)`
  ///
  /// Checks if this instant is after the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant to compare to, not null
  ///@return true if this instant is after the specified instant
  ///@throws NullPointerException if otherInstant is null
  bool isAfter(Instant? otherInstant) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _isAfter(reference.pointer, _id_isAfter as jni$_.JMethodIDPtr, _$otherInstant.pointer).boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(r'isBefore', r'(Ljava/time/Instant;)Z');

  static final _isBefore =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isBefore(java.time.Instant otherInstant)`
  ///
  /// Checks if this instant is before the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant to compare to, not null
  ///@return true if this instant is before the specified instant
  ///@throws NullPointerException if otherInstant is null
  bool isBefore(Instant? otherInstant) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _isBefore(reference.pointer, _id_isBefore as jni$_.JMethodIDPtr, _$otherInstant.pointer).boolean;
  }

  static final _id_equals = _class.instanceMethodId(r'equals', r'(Ljava/lang/Object;)Z');

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean equals(java.lang.Object otherInstant)`
  ///
  /// Checks if this instant is equal to the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant, null returns false
  ///@return true if the other instant is equal to this one
  bool equals(jni$_.JObject? otherInstant) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$otherInstant.pointer).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int hashCode()`
  ///
  /// Returns a hash code for this instant.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A string representation of this instant using ISO-8601 representation.
  ///
  /// The format used is the same as DateTimeFormatter\#ISO_INSTANT.
  ///@return an ISO-8601 representation of this instant, not null
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) => reference.isNull ? null : Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$NullableType) && other is $Instant$NullableType;
  }
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) => Instant.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$Type) && other is $Instant$Type;
  }
}

/// from: `java.time.zone.ZoneRules`
///
/// The rules defining how the zone offset varies for a single time-zone.
///
/// The rules model all the historic and future transitions for a time-zone.
/// ZoneOffsetTransition is used for known transitions, typically historic.
/// ZoneOffsetTransitionRule is used for future transitions that are based
/// on the result of an algorithm.
///
/// The rules are loaded via ZoneRulesProvider using a ZoneId.
/// The same rules may be shared internally between multiple zone IDs.
///
/// Serializing an instance of {@code ZoneRules} will store the entire set of rules.
/// It does not store the zone ID as it is not part of the state of this object.
///
/// A rule implementation may or may not store full information about historic
/// and future transitions, and the information stored is only as accurate as
/// that supplied to the implementation by the rules provider.
/// Applications should treat the data provided as representing the best information
/// available to the implementation of this rule.
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class ZoneRules extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneRules> $type;

  @jni$_.internal
  ZoneRules.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/zone/ZoneRules');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneRules$NullableType();
  static const type = $ZoneRules$Type();
  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/ZoneOffset;Ljava/time/ZoneOffset;Ljava/util/List;Ljava/util/List;Ljava/util/List;)Ljava/time/zone/ZoneRules;',
  );

  static final _of =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.zone.ZoneRules of(java.time.ZoneOffset baseStandardOffset, java.time.ZoneOffset baseWallOffset, java.util.List<java.time.zone.ZoneOffsetTransition> standardOffsetTransitionList, java.util.List<java.time.zone.ZoneOffsetTransition> transitionList, java.util.List<java.time.zone.ZoneOffsetTransitionRule> lastRules)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of a ZoneRules.
  ///@param baseStandardOffset the standard offset to use before legal rules were set, not null
  ///@param baseWallOffset the wall offset to use before legal rules were set, not null
  ///@param standardOffsetTransitionList the list of changes to the standard offset, not null
  ///@param transitionList the list of transitions, not null
  ///@param lastRules the recurring last rules, size 16 or less, not null
  ///@return the zone rules, not null
  static ZoneRules? of(
    ZoneOffset? baseStandardOffset,
    ZoneOffset? baseWallOffset,
    jni$_.JList<jni$_.JObject?>? standardOffsetTransitionList,
    jni$_.JList<jni$_.JObject?>? transitionList,
    jni$_.JList<jni$_.JObject?>? lastRules,
  ) {
    final _$baseStandardOffset = baseStandardOffset?.reference ?? jni$_.jNullReference;
    final _$baseWallOffset = baseWallOffset?.reference ?? jni$_.jNullReference;
    final _$standardOffsetTransitionList = standardOffsetTransitionList?.reference ?? jni$_.jNullReference;
    final _$transitionList = transitionList?.reference ?? jni$_.jNullReference;
    final _$lastRules = lastRules?.reference ?? jni$_.jNullReference;
    return _of(
      _class.reference.pointer,
      _id_of as jni$_.JMethodIDPtr,
      _$baseStandardOffset.pointer,
      _$baseWallOffset.pointer,
      _$standardOffsetTransitionList.pointer,
      _$transitionList.pointer,
      _$lastRules.pointer,
    ).object<ZoneRules?>(const $ZoneRules$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(r'of', r'(Ljava/time/ZoneOffset;)Ljava/time/zone/ZoneRules;');

  static final _of$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.zone.ZoneRules of(java.time.ZoneOffset offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of ZoneRules that has fixed zone rules.
  ///@param offset the offset this fixed zone rules is based on, not null
  ///@return the zone rules, not null
  ///@see \#isFixedOffset()
  static ZoneRules? of$1(ZoneOffset? offset) {
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _of$1(
      _class.reference.pointer,
      _id_of$1 as jni$_.JMethodIDPtr,
      _$offset.pointer,
    ).object<ZoneRules?>(const $ZoneRules$NullableType());
  }

  static final _id_isFixedOffset = _class.instanceMethodId(r'isFixedOffset', r'()Z');

  static final _isFixedOffset =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallBooleanMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public boolean isFixedOffset()`
  ///
  /// Checks of the zone rules are fixed, such that the offset never varies.
  ///@return true if the time-zone is fixed and the offset never changes
  bool isFixedOffset() {
    return _isFixedOffset(reference.pointer, _id_isFixedOffset as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_getOffset = _class.instanceMethodId(r'getOffset', r'(Ljava/time/Instant;)Ljava/time/ZoneOffset;');

  static final _getOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZoneOffset getOffset(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the offset applicable at the specified instant in these rules.
  ///
  /// The mapping from an instant to an offset is simple, there is only
  /// one valid offset for each instant.
  /// This method returns that offset.
  ///@param instant the instant to find the offset for, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the offset, not null
  ZoneOffset? getOffset(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _getOffset(
      reference.pointer,
      _id_getOffset as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getOffset$1 = _class.instanceMethodId(
    r'getOffset',
    r'(Ljava/time/LocalDateTime;)Ljava/time/ZoneOffset;',
  );

  static final _getOffset$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZoneOffset getOffset(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets a suitable offset for the specified local date-time in these rules.
  ///
  /// The mapping from a local date-time to an offset is not straightforward.
  /// There are three cases:
  /// <ul>
  /// <li>Normal, with one valid offset. For the vast majority of the year, the normal
  ///  case applies, where there is a single valid offset for the local date-time.</li>
  /// <li>Gap, with zero valid offsets. This is when clocks jump forward typically
  ///  due to the spring daylight savings change from "winter" to "summer".
  ///  In a gap there are local date-time values with no valid offset.</li>
  /// <li>Overlap, with two valid offsets. This is when clocks are set back typically
  ///  due to the autumn daylight savings change from "summer" to "winter".
  ///  In an overlap there are local date-time values with two valid offsets.</li>
  /// </ul>
  /// Thus, for any given local date-time there can be zero, one or two valid offsets.
  /// This method returns the single offset in the Normal case, and in the Gap or Overlap
  /// case it returns the offset before the transition.
  ///
  /// Since, in the case of Gap and Overlap, the offset returned is a "best" value, rather
  /// than the "correct" value, it should be treated with care. Applications that care
  /// about the correct offset should use a combination of this method,
  /// \#getValidOffsets(LocalDateTime) and \#getTransition(LocalDateTime).
  ///@param localDateTime the local date-time to query, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the best available offset for the local date-time, not null
  ZoneOffset? getOffset$1(jni$_.JObject? localDateTime) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    return _getOffset$1(
      reference.pointer,
      _id_getOffset$1 as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getValidOffsets = _class.instanceMethodId(
    r'getValidOffsets',
    r'(Ljava/time/LocalDateTime;)Ljava/util/List;',
  );

  static final _getValidOffsets =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.util.List<java.time.ZoneOffset> getValidOffsets(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the offset applicable at the specified local date-time in these rules.
  ///
  /// The mapping from a local date-time to an offset is not straightforward.
  /// There are three cases:
  /// <ul>
  /// <li>Normal, with one valid offset. For the vast majority of the year, the normal
  ///  case applies, where there is a single valid offset for the local date-time.</li>
  /// <li>Gap, with zero valid offsets. This is when clocks jump forward typically
  ///  due to the spring daylight savings change from "winter" to "summer".
  ///  In a gap there are local date-time values with no valid offset.</li>
  /// <li>Overlap, with two valid offsets. This is when clocks are set back typically
  ///  due to the autumn daylight savings change from "summer" to "winter".
  ///  In an overlap there are local date-time values with two valid offsets.</li>
  /// </ul>
  /// Thus, for any given local date-time there can be zero, one or two valid offsets.
  /// This method returns that list of valid offsets, which is a list of size 0, 1 or 2.
  /// In the case where there are two offsets, the earlier offset is returned at index 0
  /// and the later offset at index 1.
  ///
  /// There are various ways to handle the conversion from a {@code LocalDateTime}.
  /// One technique, using this method, would be:
  /// <pre>
  ///  List&lt;ZoneOffset&gt; validOffsets = rules.getOffset(localDT);
  ///  if (validOffsets.size() == 1) {
  ///    // Normal case: only one valid offset
  ///    zoneOffset = validOffsets.get(0);
  ///  } else {
  ///    // Gap or Overlap: determine what to do from transition (which will be non-null)
  ///    ZoneOffsetTransition trans = rules.getTransition(localDT);
  ///  }
  /// </pre>
  ///
  /// In theory, it is possible for there to be more than two valid offsets.
  /// This would happen if clocks to be put back more than once in quick succession.
  /// This has never happened in the history of time-zones and thus has no special handling.
  /// However, if it were to happen, then the list would return more than 2 entries.
  ///@param localDateTime the local date-time to query for valid offsets, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the list of valid offsets, may be immutable, not null
  jni$_.JList<ZoneOffset?>? getValidOffsets(jni$_.JObject? localDateTime) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    return _getValidOffsets(
      reference.pointer,
      _id_getValidOffsets as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<jni$_.JList<ZoneOffset?>?>(const jni$_.JListNullableType<ZoneOffset?>($ZoneOffset$NullableType()));
  }

  static final _id_getTransition = _class.instanceMethodId(
    r'getTransition',
    r'(Ljava/time/LocalDateTime;)Ljava/time/zone/ZoneOffsetTransition;',
  );

  static final _getTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.zone.ZoneOffsetTransition getTransition(java.time.LocalDateTime localDateTime)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the offset transition applicable at the specified local date-time in these rules.
  ///
  /// The mapping from a local date-time to an offset is not straightforward.
  /// There are three cases:
  /// <ul>
  /// <li>Normal, with one valid offset. For the vast majority of the year, the normal
  ///  case applies, where there is a single valid offset for the local date-time.</li>
  /// <li>Gap, with zero valid offsets. This is when clocks jump forward typically
  ///  due to the spring daylight savings change from "winter" to "summer".
  ///  In a gap there are local date-time values with no valid offset.</li>
  /// <li>Overlap, with two valid offsets. This is when clocks are set back typically
  ///  due to the autumn daylight savings change from "summer" to "winter".
  ///  In an overlap there are local date-time values with two valid offsets.</li>
  /// </ul>
  /// A transition is used to model the cases of a Gap or Overlap.
  /// The Normal case will return null.
  ///
  /// There are various ways to handle the conversion from a {@code LocalDateTime}.
  /// One technique, using this method, would be:
  /// <pre>
  ///  ZoneOffsetTransition trans = rules.getTransition(localDT);
  ///  if (trans != null) {
  ///    // Gap or Overlap: determine what to do from transition
  ///  } else {
  ///    // Normal case: only one valid offset
  ///    zoneOffset = rule.getOffset(localDT);
  ///  }
  /// </pre>
  ///@param localDateTime the local date-time to query for offset transition, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the offset transition, null if the local date-time is not in transition
  jni$_.JObject? getTransition(jni$_.JObject? localDateTime) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    return _getTransition(
      reference.pointer,
      _id_getTransition as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getStandardOffset = _class.instanceMethodId(
    r'getStandardOffset',
    r'(Ljava/time/Instant;)Ljava/time/ZoneOffset;',
  );

  static final _getStandardOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.ZoneOffset getStandardOffset(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the standard offset for the specified instant in this zone.
  ///
  /// This provides access to historic information on how the standard offset
  /// has changed over time.
  /// The standard offset is the offset before any daylight saving time is applied.
  /// This is typically the offset applicable during winter.
  ///@param instant the instant to find the offset information for, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the standard offset, not null
  ZoneOffset? getStandardOffset(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _getStandardOffset(
      reference.pointer,
      _id_getStandardOffset as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getDaylightSavings = _class.instanceMethodId(
    r'getDaylightSavings',
    r'(Ljava/time/Instant;)Ljava/time/Duration;',
  );

  static final _getDaylightSavings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.Duration getDaylightSavings(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the amount of daylight savings in use for the specified instant in this zone.
  ///
  /// This provides access to historic information on how the amount of daylight
  /// savings has changed over time.
  /// This is the difference between the standard offset and the actual offset.
  /// Typically the amount is zero during winter and one hour during summer.
  /// Time-zones are second-based, so the nanosecond part of the duration will be zero.
  ///
  /// This default implementation calculates the duration from the
  /// \#getOffset(java.time.Instant) actual and
  /// \#getStandardOffset(java.time.Instant) standard offsets.
  ///@param instant the instant to find the daylight savings for, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the difference between the standard and actual offset, not null
  jni$_.JObject? getDaylightSavings(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _getDaylightSavings(
      reference.pointer,
      _id_getDaylightSavings as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isDaylightSavings = _class.instanceMethodId(r'isDaylightSavings', r'(Ljava/time/Instant;)Z');

  static final _isDaylightSavings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean isDaylightSavings(java.time.Instant instant)`
  ///
  /// Checks if the specified instant is in daylight savings.
  ///
  /// This checks if the standard offset and the actual offset are the same
  /// for the specified instant.
  /// If they are not, it is assumed that daylight savings is in operation.
  ///
  /// This default implementation compares the \#getOffset(java.time.Instant) actual
  /// and \#getStandardOffset(java.time.Instant) standard offsets.
  ///@param instant the instant to find the offset information for, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the standard offset, not null
  bool isDaylightSavings(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _isDaylightSavings(
      reference.pointer,
      _id_isDaylightSavings as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).boolean;
  }

  static final _id_isValidOffset = _class.instanceMethodId(
    r'isValidOffset',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;)Z',
  );

  static final _isValidOffset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isValidOffset(java.time.LocalDateTime localDateTime, java.time.ZoneOffset offset)`
  ///
  /// Checks if the offset date-time is valid for these rules.
  ///
  /// To be valid, the local date-time must not be in a gap and the offset
  /// must match one of the valid offsets.
  ///
  /// This default implementation checks if \#getValidOffsets(java.time.LocalDateTime)
  /// contains the specified offset.
  ///@param localDateTime the date-time to check, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@param offset the offset to check, null returns false
  ///@return true if the offset date-time is valid for these rules
  bool isValidOffset(jni$_.JObject? localDateTime, ZoneOffset? offset) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _isValidOffset(
      reference.pointer,
      _id_isValidOffset as jni$_.JMethodIDPtr,
      _$localDateTime.pointer,
      _$offset.pointer,
    ).boolean;
  }

  static final _id_nextTransition = _class.instanceMethodId(
    r'nextTransition',
    r'(Ljava/time/Instant;)Ljava/time/zone/ZoneOffsetTransition;',
  );

  static final _nextTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.zone.ZoneOffsetTransition nextTransition(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the next transition after the specified instant.
  ///
  /// This returns details of the next transition after the specified instant.
  /// For example, if the instant represents a point where "Summer" daylight savings time
  /// applies, then the method will return the transition to the next "Winter" time.
  ///@param instant the instant to get the next transition after, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the next transition after the specified instant, null if this is after the last transition
  jni$_.JObject? nextTransition(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _nextTransition(
      reference.pointer,
      _id_nextTransition as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_previousTransition = _class.instanceMethodId(
    r'previousTransition',
    r'(Ljava/time/Instant;)Ljava/time/zone/ZoneOffsetTransition;',
  );

  static final _previousTransition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.zone.ZoneOffsetTransition previousTransition(java.time.Instant instant)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the previous transition before the specified instant.
  ///
  /// This returns details of the previous transition before the specified instant.
  /// For example, if the instant represents a point where "summer" daylight saving time
  /// applies, then the method will return the transition from the previous "winter" time.
  ///@param instant the instant to get the previous transition after, not null, but null
  ///  may be ignored if the rules have a single offset for all instants
  ///@return the previous transition before the specified instant, null if this is before the first transition
  jni$_.JObject? previousTransition(Instant? instant) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    return _previousTransition(
      reference.pointer,
      _id_previousTransition as jni$_.JMethodIDPtr,
      _$instant.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getTransitions = _class.instanceMethodId(r'getTransitions', r'()Ljava/util/List;');

  static final _getTransitions =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.util.List<java.time.zone.ZoneOffsetTransition> getTransitions()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the complete list of fully defined transitions.
  ///
  /// The complete set of transitions for this rules instance is defined by this method
  /// and \#getTransitionRules(). This method returns those transitions that have
  /// been fully defined. These are typically historical, but may be in the future.
  ///
  /// The list will be empty for fixed offset rules and for any time-zone where there has
  /// only ever been a single offset. The list will also be empty if the transition rules are unknown.
  ///@return an immutable list of fully defined transitions, not null
  jni$_.JList<jni$_.JObject?>? getTransitions() {
    return _getTransitions(
      reference.pointer,
      _id_getTransitions as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(const jni$_.JListNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_getTransitionRules = _class.instanceMethodId(r'getTransitionRules', r'()Ljava/util/List;');

  static final _getTransitionRules =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.util.List<java.time.zone.ZoneOffsetTransitionRule> getTransitionRules()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the list of transition rules for years beyond those defined in the transition list.
  ///
  /// The complete set of transitions for this rules instance is defined by this method
  /// and \#getTransitions(). This method returns instances of ZoneOffsetTransitionRule
  /// that define an algorithm for when transitions will occur.
  ///
  /// For any given {@code ZoneRules}, this list contains the transition rules for years
  /// beyond those years that have been fully defined. These rules typically refer to future
  /// daylight saving time rule changes.
  ///
  /// If the zone defines daylight savings into the future, then the list will normally
  /// be of size two and hold information about entering and exiting daylight savings.
  /// If the zone does not have daylight savings, or information about future changes
  /// is uncertain, then the list will be empty.
  ///
  /// The list will be empty for fixed offset rules and for any time-zone where there is no
  /// daylight saving time. The list will also be empty if the transition rules are unknown.
  ///@return an immutable list of transition rules, not null
  jni$_.JList<jni$_.JObject?>? getTransitionRules() {
    return _getTransitionRules(
      reference.pointer,
      _id_getTransitionRules as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(const jni$_.JListNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_equals = _class.instanceMethodId(r'equals', r'(Ljava/lang/Object;)Z');

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean equals(java.lang.Object otherRules)`
  ///
  /// Checks if this set of rules equals another.
  ///
  /// Two rule sets are equal if they will always result in the same output
  /// for any given input instant or local date-time.
  /// Rules from two different groups may return false even if they are in fact the same.
  ///
  /// This definition should result in implementations comparing their entire state.
  ///@param otherRules the other rules, null returns false
  ///@return true if this rules is the same as that specified
  bool equals(jni$_.JObject? otherRules) {
    final _$otherRules = otherRules?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$otherRules.pointer).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallIntMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public int hashCode()`
  ///
  /// Returns a suitable hash code given the definition of {@code \#equals}.
  ///@return the hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a string describing this object.
  ///@return a string for debugging, not null
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneRules$NullableType extends jni$_.JObjType<ZoneRules?> {
  @jni$_.internal
  const $ZoneRules$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/zone/ZoneRules;';

  @jni$_.internal
  @core$_.override
  ZoneRules? fromReference(jni$_.JReference reference) => reference.isNull ? null : ZoneRules.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneRules?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneRules$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneRules$NullableType) && other is $ZoneRules$NullableType;
  }
}

final class $ZoneRules$Type extends jni$_.JObjType<ZoneRules> {
  @jni$_.internal
  const $ZoneRules$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/zone/ZoneRules;';

  @jni$_.internal
  @core$_.override
  ZoneRules fromReference(jni$_.JReference reference) => ZoneRules.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneRules?> get nullableType => const $ZoneRules$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneRules$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneRules$Type) && other is $ZoneRules$Type;
  }
}

/// from: `java.time.format.DateTimeFormatter`
///
/// Formatter for printing and parsing date-time objects.
///
/// This class provides the main application entry point for printing and parsing
/// and provides common implementations of {@code DateTimeFormatter}:
/// <ul>
/// <li>Using predefined constants, such as \#ISO_LOCAL_DATE</li>
/// <li>Using pattern letters, such as {@code uuuu-MMM-dd}</li>
/// <li>Using localized styles, such as {@code long} or {@code medium}</li>
/// </ul>
///
/// More complex formatters are provided by
/// DateTimeFormatterBuilder DateTimeFormatterBuilder.
///
///
/// The main date-time classes provide two methods - one for formatting,
/// {@code format(DateTimeFormatter formatter)}, and one for parsing,
/// {@code parse(CharSequence text, DateTimeFormatter formatter)}.
/// For example:
/// <blockquote><pre>
///  LocalDate date = LocalDate.now();
///  String text = date.format(formatter);
///  LocalDate parsedDate = LocalDate.parse(text, formatter);
/// </pre></blockquote>
///
/// In addition to the format, formatters can be created with desired Locale,
/// Chronology, ZoneId, and DecimalStyle.
///
/// The \#withLocale withLocale method returns a new formatter that
/// overrides the locale. The locale affects some aspects of formatting and
/// parsing. For example, the \#ofLocalizedDate ofLocalizedDate provides a
/// formatter that uses the locale specific date format.
///
/// The \#withChronology withChronology method returns a new formatter
/// that overrides the chronology. If overridden, the date-time value is
/// converted to the chronology before formatting. During parsing the date-time
/// value is converted to the chronology before it is returned.
///
/// The \#withZone withZone method returns a new formatter that overrides
/// the zone. If overridden, the date-time value is converted to a ZonedDateTime
/// with the requested ZoneId before formatting. During parsing the ZoneId is
/// applied before the value is returned.
///
/// The \#withDecimalStyle withDecimalStyle method returns a new formatter that
/// overrides the DecimalStyle. The DecimalStyle symbols are used for
/// formatting and parsing.
///
/// Some applications may need to use the older Format java.text.Format
/// class for formatting. The \#toFormat() method returns an
/// implementation of {@code java.text.Format}.
///
/// <h3 id="predefined">Predefined Formatters</h3>
/// <table class="striped"style="text-align:left">
/// <caption>Predefined Formatters</caption>
/// <thead>
/// <tr>
/// <th scope="col">Formatter</th>
/// <th scope="col">Description</th>
/// <th scope="col">Example</th>
/// </tr>
/// </thead>
/// <tbody>
/// <tr>
/// <th scope="row">\#ofLocalizedDate ofLocalizedDate(dateStyle) </th>
/// <td> Formatter with date style from the locale </td>
/// <td> '2011-12-03'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ofLocalizedTime ofLocalizedTime(timeStyle) </th>
/// <td> Formatter with time style from the locale </td>
/// <td> '10:15:30'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle) </th>
/// <td> Formatter with a style for date and time from the locale</td>
/// <td> '3 Jun 2008 11:05:30'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)
/// </th>
/// <td> Formatter with date and time styles from the locale </td>
/// <td> '3 Jun 2008 11:05'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#BASIC_ISO_DATE</th>
/// <td>Basic ISO date </td> <td>'20111203'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_LOCAL_DATE</th>
/// <td> ISO Local Date </td>
/// <td>'2011-12-03'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_OFFSET_DATE</th>
/// <td> ISO Date with offset </td>
/// <td>'2011-12-03+01:00'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_DATE</th>
/// <td> ISO Date with or without offset </td>
/// <td> '2011-12-03+01:00'; '2011-12-03'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_LOCAL_TIME</th>
/// <td> Time without offset </td>
/// <td>'10:15:30'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_OFFSET_TIME</th>
/// <td> Time with offset </td>
/// <td>'10:15:30+01:00'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_TIME</th>
/// <td> Time with or without offset </td>
/// <td>'10:15:30+01:00'; '10:15:30'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_LOCAL_DATE_TIME</th>
/// <td> ISO Local Date and Time </td>
/// <td>'2011-12-03T10:15:30'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_OFFSET_DATE_TIME</th>
/// <td> Date Time with Offset
/// </td><td>'2011-12-03T10:15:30+01:00'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_ZONED_DATE_TIME</th>
/// <td> Zoned Date Time </td>
/// <td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_DATE_TIME</th>
/// <td> Date and time with ZoneId </td>
/// <td>'2011-12-03T10:15:30+01:00[Europe/Paris]'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_ORDINAL_DATE</th>
/// <td> Year and day of year </td>
/// <td>'2012-337'</td>
/// </tr>
/// <tr>
/// <th scope="row"> \#ISO_WEEK_DATE</th>
/// <td> Year and Week </td>
/// <td>'2012-W48-6'</td></tr>
/// <tr>
/// <th scope="row"> \#ISO_INSTANT</th>
/// <td> Date and Time of an Instant </td>
/// <td>'2011-12-03T10:15:30Z' </td>
/// </tr>
/// <tr>
/// <th scope="row"> \#RFC_1123_DATE_TIME</th>
/// <td> RFC 1123 / RFC 822 </td>
/// <td>'Tue, 3 Jun 2008 11:05:30 GMT'</td>
/// </tr>
/// </tbody>
/// </table>
///
/// <h3 id="patterns">Patterns for Formatting and Parsing</h3>
/// Patterns are based on a simple sequence of letters and symbols.
/// A pattern is used to create a Formatter using the
/// \#ofPattern(String) and \#ofPattern(String, Locale) methods.
/// For example,
/// {@code "d MMM uuuu"} will format 2011-12-03 as '3&nbsp;Dec&nbsp;2011'.
/// A formatter created from a pattern can be used as many times as necessary,
/// it is immutable and is thread-safe.
///
/// For example:
/// <blockquote><pre>
///  LocalDate date = LocalDate.now();
///  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy MM dd");
///  String text = date.format(formatter);
///  LocalDate parsedDate = LocalDate.parse(text, formatter);
/// </pre></blockquote>
///
/// All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The
/// following pattern letters are defined:
/// <table class="striped">
/// <caption>Pattern Letters and Symbols</caption>
/// <thead>
///  <tr><th scope="col">Symbol</th>   <th scope="col">Meaning</th>         <th scope="col">Presentation</th> <th scope="col">Examples</th>
/// </thead>
/// <tbody>
///   <tr><th scope="row">G</th>       <td>era</td>                         <td>text</td>              <td>AD; Anno Domini; A</td>
///   <tr><th scope="row">u</th>       <td>year</td>                        <td>year</td>              <td>2004; 04</td>
///   <tr><th scope="row">y</th>       <td>year-of-era</td>                 <td>year</td>              <td>2004; 04</td>
///   <tr><th scope="row">D</th>       <td>day-of-year</td>                 <td>number</td>            <td>189</td>
///   <tr><th scope="row">M/L</th>     <td>month-of-year</td>               <td>number/text</td>       <td>7; 07; Jul; July; J</td>
///   <tr><th scope="row">d</th>       <td>day-of-month</td>                <td>number</td>            <td>10</td>
///   <tr><th scope="row">g</th>       <td>modified-julian-day</td>         <td>number</td>            <td>2451334</td>
///
///   <tr><th scope="row">Q/q</th>     <td>quarter-of-year</td>             <td>number/text</td>       <td>3; 03; Q3; 3rd quarter</td>
///   <tr><th scope="row">Y</th>       <td>week-based-year</td>             <td>year</td>              <td>1996; 96</td>
///   <tr><th scope="row">w</th>       <td>week-of-week-based-year</td>     <td>number</td>            <td>27</td>
///   <tr><th scope="row">W</th>       <td>week-of-month</td>               <td>number</td>            <td>4</td>
///   <tr><th scope="row">E</th>       <td>day-of-week</td>                 <td>text</td>              <td>Tue; Tuesday; T</td>
///   <tr><th scope="row">e/c</th>     <td>localized day-of-week</td>       <td>number/text</td>       <td>2; 02; Tue; Tuesday; T</td>
///   <tr><th scope="row">F</th>       <td>day-of-week-in-month</td>        <td>number</td>            <td>3</td>
///
///   <tr><th scope="row">a</th>       <td>am-pm-of-day</td>                <td>text</td>              <td>PM</td>
///   <tr><th scope="row">h</th>       <td>clock-hour-of-am-pm (1-12)</td>  <td>number</td>            <td>12</td>
///   <tr><th scope="row">K</th>       <td>hour-of-am-pm (0-11)</td>        <td>number</td>            <td>0</td>
///   <tr><th scope="row">k</th>       <td>clock-hour-of-day (1-24)</td>    <td>number</td>            <td>24</td>
///
///   <tr><th scope="row">H</th>       <td>hour-of-day (0-23)</td>          <td>number</td>            <td>0</td>
///   <tr><th scope="row">m</th>       <td>minute-of-hour</td>              <td>number</td>            <td>30</td>
///   <tr><th scope="row">s</th>       <td>second-of-minute</td>            <td>number</td>            <td>55</td>
///   <tr><th scope="row">S</th>       <td>fraction-of-second</td>          <td>fraction</td>          <td>978</td>
///   <tr><th scope="row">A</th>       <td>milli-of-day</td>                <td>number</td>            <td>1234</td>
///   <tr><th scope="row">n</th>       <td>nano-of-second</td>              <td>number</td>            <td>987654321</td>
///   <tr><th scope="row">N</th>       <td>nano-of-day</td>                 <td>number</td>            <td>1234000000</td>
///
///   <tr><th scope="row">V</th>       <td>time-zone ID</td>                <td>zone-id</td>           <td>America/Los_Angeles; Z; -08:30</td>
///   <tr><th scope="row">v</th>       <td>generic time-zone name</td>      <td>zone-name</td>         <td>Pacific Time; PT</td>
///   <tr><th scope="row">z</th>       <td>time-zone name</td>              <td>zone-name</td>         <td>Pacific Standard Time; PST</td>
///   <tr><th scope="row">O</th>       <td>localized zone-offset</td>       <td>offset-O</td>          <td>GMT+8; GMT+08:00; UTC-08:00</td>
///   <tr><th scope="row">X</th>       <td>zone-offset 'Z' for zero</td>    <td>offset-X</td>          <td>Z; -08; -0830; -08:30; -083015; -08:30:15</td>
///   <tr><th scope="row">x</th>       <td>zone-offset</td>                 <td>offset-x</td>          <td>+0000; -08; -0830; -08:30; -083015; -08:30:15</td>
///   <tr><th scope="row">Z</th>       <td>zone-offset</td>                 <td>offset-Z</td>          <td>+0000; -0800; -08:00</td>
///
///   <tr><th scope="row">p</th>       <td>pad next</td>                    <td>pad modifier</td>      <td>1</td>
///
///   <tr><th scope="row">'</th>       <td>escape for text</td>             <td>delimiter</td>         <td></td>
///   <tr><th scope="row">''</th>      <td>single quote</td>                <td>literal</td>           <td>'</td>
///   <tr><th scope="row">[</th>       <td>optional section start</td>      <td></td>                  <td></td>
///   <tr><th scope="row">]</th>       <td>optional section end</td>        <td></td>                  <td></td>
///   <tr><th scope="row">\#</th>       <td>reserved for future use</td>     <td></td>                  <td></td>
///   <tr><th scope="row">{</th>       <td>reserved for future use</td>     <td></td>                  <td></td>
///   <tr><th scope="row">}</th>       <td>reserved for future use</td>     <td></td>                  <td></td>
/// </tbody>
/// </table>
///
/// The count of pattern letters determines the format.
///
/// __Text__: The text style is determined based on the number of pattern
/// letters used. Less than 4 pattern letters will use the
/// TextStyle\#SHORT short form. Exactly 4 pattern letters will use the
/// TextStyle\#FULL full form. Exactly 5 pattern letters will use the
/// TextStyle\#NARROW narrow form.
/// Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles.
///
/// __Number__: If the count of letters is one, then the value is output using
/// the minimum number of digits and without padding. Otherwise, the count of digits
/// is used as the width of the output field, with the value zero-padded as necessary.
/// The following pattern letters have constraints on the count of letters.
/// Only one letter of 'c' and 'F' can be specified.
/// Up to two letters of 'd', 'H', 'h', 'K', 'k', 'm', and 's' can be specified.
/// Up to three letters of 'D' can be specified.
///
/// __Number/Text__: If the count of pattern letters is 3 or greater, use the
/// Text rules above. Otherwise use the Number rules above.
///
/// __Fraction__: Outputs the nano-of-second field as a fraction-of-second.
/// The nano-of-second value has nine digits, thus the count of pattern letters
/// is from 1 to 9. If it is less than 9, then the nano-of-second value is
/// truncated, with only the most significant digits being output.
///
/// __Year__: The count of letters determines the minimum field width below
/// which padding is used. If the count of letters is two, then a
/// DateTimeFormatterBuilder\#appendValueReduced reduced two digit form is
/// used. For printing, this outputs the rightmost two digits. For parsing, this
/// will parse using the base value of 2000, resulting in a year within the range
/// 2000 to 2099 inclusive. If the count of letters is less than four (but not
/// two), then the sign is only output for negative years as per
/// SignStyle\#NORMAL. Otherwise, the sign is output if the pad width is
/// exceeded, as per SignStyle\#EXCEEDS_PAD.
///
/// __ZoneId__: This outputs the time-zone ID, such as 'Europe/Paris'. If the
/// count of letters is two, then the time-zone ID is output. Any other count of
/// letters throws {@code IllegalArgumentException}.
///
/// __Zone names__: This outputs the display name of the time-zone ID. If the
/// pattern letter is 'z' the output is the daylight savings aware zone name.
/// If there is insufficient information to determine whether DST applies,
/// the name ignoring daylight savings time will be used.
/// If the count of letters is one, two or three, then the short name is output.
/// If the count of letters is four, then the full name is output.
/// Five or more letters throws {@code IllegalArgumentException}.
///
/// If the pattern letter is 'v' the output provides the zone name ignoring
/// daylight savings time. If the count of letters is one, then the short name is output.
/// If the count of letters is four, then the full name is output.
/// Two, three and five or more letters throw {@code IllegalArgumentException}.
///
/// __Offset X and x__: This formats the offset based on the number of pattern
/// letters. One letter outputs just the hour, such as '+01', unless the minute
/// is non-zero in which case the minute is also output, such as '+0130'. Two
/// letters outputs the hour and minute, without a colon, such as '+0130'. Three
/// letters outputs the hour and minute, with a colon, such as '+01:30'. Four
/// letters outputs the hour and minute and optional second, without a colon,
/// such as '+013015'. Five letters outputs the hour and minute and optional
/// second, with a colon, such as '+01:30:15'. Six or more letters throws
/// {@code IllegalArgumentException}. Pattern letter 'X' (upper case) will output
/// 'Z' when the offset to be output would be zero, whereas pattern letter 'x'
/// (lower case) will output '+00', '+0000', or '+00:00'.
///
/// __Offset O__: This formats the localized offset based on the number of
/// pattern letters. One letter outputs the {@linkplain TextStyle\#SHORT short}
/// form of the localized offset, which is localized offset text, such as 'GMT',
/// with hour without leading zero, optional 2-digit minute and second if
/// non-zero, and colon, for example 'GMT+8'. Four letters outputs the
/// {@linkplain TextStyle\#FULL full} form, which is localized offset text,
/// such as 'GMT, with 2-digit hour and minute field, optional second field
/// if non-zero, and colon, for example 'GMT+08:00'. Any other count of letters
/// throws {@code IllegalArgumentException}.
///
/// __Offset Z__: This formats the offset based on the number of pattern
/// letters. One, two or three letters outputs the hour and minute, without a
/// colon, such as '+0130'. The output will be '+0000' when the offset is zero.
/// Four letters outputs the {@linkplain TextStyle\#FULL full} form of localized
/// offset, equivalent to four letters of Offset-O. The output will be the
/// corresponding localized offset text if the offset is zero. Five
/// letters outputs the hour, minute, with optional second if non-zero, with
/// colon. It outputs 'Z' if the offset is zero.
/// Six or more letters throws {@code IllegalArgumentException}.
///
/// __Optional section__: The optional section markers work exactly like
/// calling DateTimeFormatterBuilder\#optionalStart() and
/// DateTimeFormatterBuilder\#optionalEnd().
///
/// __Pad modifier__: Modifies the pattern that immediately follows to be
/// padded with spaces. The pad width is determined by the number of pattern
/// letters. This is the same as calling
/// DateTimeFormatterBuilder\#padNext(int).
///
/// For example, 'ppH' outputs the hour-of-day padded on the left with spaces to
/// a width of 2.
///
/// Any unrecognized letter is an error. Any non-letter character, other than
/// '[', ']', '{', '}', '\#' and the single quote will be output directly.
/// Despite this, it is recommended to use single quotes around all characters
/// that you want to output directly to ensure that future changes do not break
/// your application.
///
/// <h3 id="resolving">Resolving</h3>
/// Parsing is implemented as a two-phase operation.
/// First, the text is parsed using the layout defined by the formatter, producing
/// a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
/// Second, the parsed data is _resolved_, by validating, combining and
/// simplifying the various fields into more useful ones.
///
/// Five parsing methods are supplied by this class.
/// Four of these perform both the parse and resolve phases.
/// The fifth method, \#parseUnresolved(CharSequence, ParsePosition),
/// only performs the first phase, leaving the result unresolved.
/// As such, it is essentially a low-level operation.
///
/// The resolve phase is controlled by two parameters, set on this class.
///
/// The ResolverStyle is an enum that offers three different approaches,
/// strict, smart and lenient. The smart option is the default.
/// It can be set using \#withResolverStyle(ResolverStyle).
///
/// The \#withResolverFields(TemporalField...) parameter allows the
/// set of fields that will be resolved to be filtered before resolving starts.
/// For example, if the formatter has parsed a year, month, day-of-month
/// and day-of-year, then there are two approaches to resolve a date:
/// (year + month + day-of-month) and (year + day-of-year).
/// The resolver fields allows one of the two approaches to be selected.
/// If no resolver fields are set then both approaches must result in the same date.
///
/// Resolving separate fields to form a complete date and time is a complex
/// process with behaviour distributed across a number of classes.
/// It follows these steps:
/// <ol>
/// <li>The chronology is determined.
/// The chronology of the result is either the chronology that was parsed,
/// or if no chronology was parsed, it is the chronology set on this class,
/// or if that is null, it is {@code IsoChronology}.
/// <li>The {@code ChronoField} date fields are resolved.
/// This is achieved using Chronology\#resolveDate(Map, ResolverStyle).
/// Documentation about field resolution is located in the implementation
/// of {@code Chronology}.
/// <li>The {@code ChronoField} time fields are resolved.
/// This is documented on ChronoField and is the same for all chronologies.
/// <li>Any fields that are not {@code ChronoField} are processed.
/// This is achieved using TemporalField\#resolve(Map, TemporalAccessor, ResolverStyle).
/// Documentation about field resolution is located in the implementation
/// of {@code TemporalField}.
/// <li>The {@code ChronoField} date and time fields are re-resolved.
/// This allows fields in step four to produce {@code ChronoField} values
/// and have them be processed into dates and times.
/// <li>A {@code LocalTime} is formed if there is at least an hour-of-day available.
/// This involves providing default values for minute, second and fraction of second.
/// <li>Any remaining unresolved fields are cross-checked against any
/// date and/or time that was resolved. Thus, an earlier stage would resolve
/// (year + month + day-of-month) to a date, and this stage would check that
/// day-of-week was valid for the date.
/// <li>If an {@linkplain \#parsedExcessDays() excess number of days}
/// was parsed then it is added to the date if a date is available.
/// <li> If a second-based field is present, but {@code LocalTime} was not parsed,
/// then the resolver ensures that milli, micro and nano second values are
/// available to meet the contract of ChronoField.
/// These will be set to zero if missing.
/// <li>If both date and time were parsed and either an offset or zone is present,
/// the field ChronoField\#INSTANT_SECONDS is created.
/// If an offset was parsed then the offset will be combined with the
/// {@code LocalDateTime} to form the instant, with any zone ignored.
/// If a {@code ZoneId} was parsed without an offset then the zone will be
/// combined with the {@code LocalDateTime} to form the instant using the rules
/// of ChronoLocalDateTime\#atZone(ZoneId).
/// </ol>
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class DateTimeFormatter extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<DateTimeFormatter> $type;

  @jni$_.internal
  DateTimeFormatter.fromReference(jni$_.JReference reference) : $type = type, super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/format/DateTimeFormatter');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $DateTimeFormatter$NullableType();
  static const type = $DateTimeFormatter$Type();
  static final _id_ISO_LOCAL_DATE = _class.staticFieldId(r'ISO_LOCAL_DATE', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_LOCAL_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses a date without an
  /// offset, such as '2011-12-03'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended local date format.
  /// The format consists of:
  /// <ul>
  /// <li>Four digits or more for the ChronoField\#YEAR year.
  /// Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
  /// Years outside that range will have a prefixed positive or negative symbol.
  /// <li>A dash
  /// <li>Two digits for the ChronoField\#MONTH_OF_YEAR month-of-year.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>A dash
  /// <li>Two digits for the ChronoField\#DAY_OF_MONTH day-of-month.
  ///  This is pre-padded by zero to ensure two digits.
  /// </ul>
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_LOCAL_DATE =>
      _id_ISO_LOCAL_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_OFFSET_DATE = _class.staticFieldId(r'ISO_OFFSET_DATE', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_OFFSET_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses a date with an
  /// offset, such as '2011-12-03+01:00'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended offset date format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_DATE
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_OFFSET_DATE =>
      _id_ISO_OFFSET_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_DATE = _class.staticFieldId(r'ISO_DATE', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses a date with the
  /// offset if available, such as '2011-12-03' or '2011-12-03+01:00'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended date format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_DATE
  /// <li>If the offset is not available then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_DATE => _id_ISO_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_LOCAL_TIME = _class.staticFieldId(r'ISO_LOCAL_TIME', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_LOCAL_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO time formatter that formats or parses a time without an
  /// offset, such as '10:15' or '10:15:30'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended local time format.
  /// The format consists of:
  /// <ul>
  /// <li>Two digits for the ChronoField\#HOUR_OF_DAY hour-of-day.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>A colon
  /// <li>Two digits for the ChronoField\#MINUTE_OF_HOUR minute-of-hour.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>If the second-of-minute is not available then the format is complete.
  /// <li>A colon
  /// <li>Two digits for the ChronoField\#SECOND_OF_MINUTE second-of-minute.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>If the nano-of-second is zero or not available then the format is complete.
  /// <li>A decimal point
  /// <li>One to nine digits for the ChronoField\#NANO_OF_SECOND nano-of-second.
  ///  As many digits will be output as required.
  /// </ul>
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_LOCAL_TIME =>
      _id_ISO_LOCAL_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_OFFSET_TIME = _class.staticFieldId(r'ISO_OFFSET_TIME', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_OFFSET_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO time formatter that formats or parses a time with an
  /// offset, such as '10:15+01:00' or '10:15:30+01:00'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended offset time format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_TIME
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_OFFSET_TIME =>
      _id_ISO_OFFSET_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_TIME = _class.staticFieldId(r'ISO_TIME', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO time formatter that formats or parses a time, with the
  /// offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended offset time format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_TIME
  /// <li>If the offset is not available then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_TIME => _id_ISO_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_LOCAL_DATE_TIME = _class.staticFieldId(
    r'ISO_LOCAL_DATE_TIME',
    r'Ljava/time/format/DateTimeFormatter;',
  );

  /// from: `static public final java.time.format.DateTimeFormatter ISO_LOCAL_DATE_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date-time formatter that formats or parses a date-time without
  /// an offset, such as '2011-12-03T10:15:30'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended offset date-time format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_DATE
  /// <li>The letter 'T'. Parsing is case insensitive.
  /// <li>The \#ISO_LOCAL_TIME
  /// </ul>
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_LOCAL_DATE_TIME =>
      _id_ISO_LOCAL_DATE_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_OFFSET_DATE_TIME = _class.staticFieldId(
    r'ISO_OFFSET_DATE_TIME',
    r'Ljava/time/format/DateTimeFormatter;',
  );

  /// from: `static public final java.time.format.DateTimeFormatter ISO_OFFSET_DATE_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date-time formatter that formats or parses a date-time with an
  /// offset, such as '2011-12-03T10:15:30+01:00'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended offset date-time format.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_DATE_TIME
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  The offset parsing is lenient, which allows the minutes and seconds to be optional.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_OFFSET_DATE_TIME =>
      _id_ISO_OFFSET_DATE_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_ZONED_DATE_TIME = _class.staticFieldId(
    r'ISO_ZONED_DATE_TIME',
    r'Ljava/time/format/DateTimeFormatter;',
  );

  /// from: `static public final java.time.format.DateTimeFormatter ISO_ZONED_DATE_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO-like date-time formatter that formats or parses a date-time with
  /// offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// a format that extends the ISO-8601 extended offset date-time format
  /// to add the time-zone.
  /// The section in square brackets is not part of the ISO-8601 standard.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_OFFSET_DATE_TIME
  /// <li>If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
  /// <li>An open square bracket '['.
  /// <li>The ZoneId\#getId() zone ID. This is not part of the ISO-8601 standard.
  ///  Parsing is case sensitive.
  /// <li>A close square bracket ']'.
  /// </ul>
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_ZONED_DATE_TIME =>
      _id_ISO_ZONED_DATE_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_DATE_TIME = _class.staticFieldId(r'ISO_DATE_TIME', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_DATE_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO-like date-time formatter that formats or parses a date-time with
  /// the offset and zone if available, such as '2011-12-03T10:15:30',
  /// '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended local or offset date-time format, as well as the
  /// extended non-ISO form specifying the time-zone.
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_LOCAL_DATE_TIME
  /// <li>If the offset is not available to format or parse then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  /// <li>If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
  /// <li>An open square bracket '['.
  /// <li>The ZoneId\#getId() zone ID. This is not part of the ISO-8601 standard.
  ///  Parsing is case sensitive.
  /// <li>A close square bracket ']'.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_DATE_TIME => _id_ISO_DATE_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_ORDINAL_DATE = _class.staticFieldId(
    r'ISO_ORDINAL_DATE',
    r'Ljava/time/format/DateTimeFormatter;',
  );

  /// from: `static public final java.time.format.DateTimeFormatter ISO_ORDINAL_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses the ordinal date
  /// without an offset, such as '2012-337'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended ordinal date format.
  /// The format consists of:
  /// <ul>
  /// <li>Four digits or more for the ChronoField\#YEAR year.
  /// Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
  /// Years outside that range will have a prefixed positive or negative symbol.
  /// <li>A dash
  /// <li>Three digits for the ChronoField\#DAY_OF_YEAR day-of-year.
  ///  This is pre-padded by zero to ensure three digits.
  /// <li>If the offset is not available to format or parse then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_ORDINAL_DATE =>
      _id_ISO_ORDINAL_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_WEEK_DATE = _class.staticFieldId(r'ISO_WEEK_DATE', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_WEEK_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses the week-based date
  /// without an offset, such as '2012-W48-6'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 extended week-based date format.
  /// The format consists of:
  /// <ul>
  /// <li>Four digits or more for the IsoFields\#WEEK_BASED_YEAR week-based-year.
  /// Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
  /// Years outside that range will have a prefixed positive or negative symbol.
  /// <li>A dash
  /// <li>The letter 'W'. Parsing is case insensitive.
  /// <li>Two digits for the IsoFields\#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year.
  ///  This is pre-padded by zero to ensure three digits.
  /// <li>A dash
  /// <li>One digit for the ChronoField\#DAY_OF_WEEK day-of-week.
  ///  The value run from Monday (1) to Sunday (7).
  /// <li>If the offset is not available to format or parse then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID. If the offset has seconds then
  ///  they will be handled even though this is not part of the ISO-8601 standard.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_WEEK_DATE => _id_ISO_WEEK_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ISO_INSTANT = _class.staticFieldId(r'ISO_INSTANT', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter ISO_INSTANT`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO instant formatter that formats or parses an instant in UTC,
  /// such as '2011-12-03T10:15:30Z'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 instant format.
  /// When formatting, the second-of-minute is always output.
  /// The nano-of-second outputs zero, three, six or nine digits as necessary.
  /// When parsing, time to at least the seconds field is required.
  /// Fractional seconds from zero to nine are parsed.
  /// The localized decimal style is not used.
  ///
  /// This is a special case formatter intended to allow a human readable form
  /// of an java.time.Instant. The {@code Instant} class is designed to
  /// only represent a point in time and internally stores a value in nanoseconds
  /// from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be
  /// formatted as a date or time without providing some form of time-zone.
  /// This formatter allows the {@code Instant} to be formatted, by providing
  /// a suitable conversion using {@code ZoneOffset.UTC}.
  ///
  /// The format consists of:
  /// <ul>
  /// <li>The \#ISO_OFFSET_DATE_TIME where the instant is converted from
  ///  ChronoField\#INSTANT_SECONDS and ChronoField\#NANO_OF_SECOND
  ///  using the {@code UTC} offset. Parsing is case insensitive.
  /// </ul>
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get ISO_INSTANT => _id_ISO_INSTANT.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_BASIC_ISO_DATE = _class.staticFieldId(r'BASIC_ISO_DATE', r'Ljava/time/format/DateTimeFormatter;');

  /// from: `static public final java.time.format.DateTimeFormatter BASIC_ISO_DATE`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The ISO date formatter that formats or parses a date without an
  /// offset, such as '20111203'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// the ISO-8601 basic local date format.
  /// The format consists of:
  /// <ul>
  /// <li>Four digits for the ChronoField\#YEAR year.
  ///  Only years in the range 0000 to 9999 are supported.
  /// <li>Two digits for the ChronoField\#MONTH_OF_YEAR month-of-year.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>Two digits for the ChronoField\#DAY_OF_MONTH day-of-month.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>If the offset is not available to format or parse then the format is complete.
  /// <li>The ZoneOffset\#getId() offset ID without colons. If the offset has
  ///  seconds then they will be handled even though this is not part of the ISO-8601 standard.
  ///  The offset parsing is lenient, which allows the minutes and seconds to be optional.
  ///  Parsing is case insensitive.
  /// </ul>
  ///
  /// As this formatter has an optional element, it may be necessary to parse using
  /// DateTimeFormatter\#parseBest.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#STRICT STRICT resolver style.
  static DateTimeFormatter? get BASIC_ISO_DATE =>
      _id_BASIC_ISO_DATE.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_RFC_1123_DATE_TIME = _class.staticFieldId(
    r'RFC_1123_DATE_TIME',
    r'Ljava/time/format/DateTimeFormatter;',
  );

  /// from: `static public final java.time.format.DateTimeFormatter RFC_1123_DATE_TIME`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30 GMT'.
  ///
  /// This returns an immutable formatter capable of formatting and parsing
  /// most of the RFC-1123 format.
  /// RFC-1123 updates RFC-822 changing the year from two digits to four.
  /// This implementation requires a four digit year.
  /// This implementation also does not handle North American or military zone
  /// names, only 'GMT' and offset amounts.
  ///
  /// The format consists of:
  /// <ul>
  /// <li>If the day-of-week is not available to format or parse then jump to day-of-month.
  /// <li>Three letter ChronoField\#DAY_OF_WEEK day-of-week in English.
  /// <li>A comma
  /// <li>A space
  /// <li>One or two digits for the ChronoField\#DAY_OF_MONTH day-of-month.
  /// <li>A space
  /// <li>Three letter ChronoField\#MONTH_OF_YEAR month-of-year in English.
  /// <li>A space
  /// <li>Four digits for the ChronoField\#YEAR year.
  ///  Only years in the range 0000 to 9999 are supported.
  /// <li>A space
  /// <li>Two digits for the ChronoField\#HOUR_OF_DAY hour-of-day.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>A colon
  /// <li>Two digits for the ChronoField\#MINUTE_OF_HOUR minute-of-hour.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>If the second-of-minute is not available then jump to the next space.
  /// <li>A colon
  /// <li>Two digits for the ChronoField\#SECOND_OF_MINUTE second-of-minute.
  ///  This is pre-padded by zero to ensure two digits.
  /// <li>A space
  /// <li>The ZoneOffset\#getId() offset ID without colons or seconds.
  ///  An offset of zero uses "GMT". North American zone names and military zone names are not handled.
  /// </ul>
  ///
  /// Parsing is case insensitive.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#SMART SMART resolver style.
  static DateTimeFormatter? get RFC_1123_DATE_TIME =>
      _id_RFC_1123_DATE_TIME.get(_class, const $DateTimeFormatter$NullableType());

  static final _id_ofPattern = _class.staticMethodId(
    r'ofPattern',
    r'(Ljava/lang/String;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofPattern =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofPattern(java.lang.String pattern)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a formatter using the specified pattern.
  ///
  /// This method will create a formatter based on a simple
  /// <a href="\#patterns">pattern of letters and symbols</a>
  /// as described in the class documentation.
  /// For example, {@code d MMM uuuu} will format 2011-12-03 as '3 Dec 2011'.
  ///
  /// The formatter will use the Locale\#getDefault(Locale.Category) default FORMAT locale.
  /// This can be changed using DateTimeFormatter\#withLocale(Locale) on the returned formatter.
  /// Alternatively use the \#ofPattern(String, Locale) variant of this method.
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses ResolverStyle\#SMART SMART resolver style.
  ///@param pattern the pattern to use, not null
  ///@return the formatter based on the pattern, not null
  ///@throws IllegalArgumentException if the pattern is invalid
  ///@see DateTimeFormatterBuilder\#appendPattern(String)
  static DateTimeFormatter? ofPattern(jni$_.JString? pattern) {
    final _$pattern = pattern?.reference ?? jni$_.jNullReference;
    return _ofPattern(
      _class.reference.pointer,
      _id_ofPattern as jni$_.JMethodIDPtr,
      _$pattern.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_ofPattern$1 = _class.staticMethodId(
    r'ofPattern',
    r'(Ljava/lang/String;Ljava/util/Locale;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofPattern$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofPattern(java.lang.String pattern, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a formatter using the specified pattern and locale.
  ///
  /// This method will create a formatter based on a simple
  /// <a href="\#patterns">pattern of letters and symbols</a>
  /// as described in the class documentation.
  /// For example, {@code d MMM uuuu} will format 2011-12-03 as '3 Dec 2011'.
  ///
  /// The formatter will use the specified locale.
  /// This can be changed using DateTimeFormatter\#withLocale(Locale) on the returned formatter.
  ///
  /// The returned formatter has no override chronology or zone.
  /// It uses ResolverStyle\#SMART SMART resolver style.
  ///@param pattern the pattern to use, not null
  ///@param locale the locale to use, not null
  ///@return the formatter based on the pattern, not null
  ///@throws IllegalArgumentException if the pattern is invalid
  ///@see DateTimeFormatterBuilder\#appendPattern(String)
  static DateTimeFormatter? ofPattern$1(jni$_.JString? pattern, jni$_.JObject? locale) {
    final _$pattern = pattern?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _ofPattern$1(
      _class.reference.pointer,
      _id_ofPattern$1 as jni$_.JMethodIDPtr,
      _$pattern.pointer,
      _$locale.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_ofLocalizedDate = _class.staticMethodId(
    r'ofLocalizedDate',
    r'(Ljava/time/format/FormatStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofLocalizedDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofLocalizedDate(java.time.format.FormatStyle dateStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a locale specific date format for the ISO chronology.
  ///
  /// This returns a formatter that will format or parse a date.
  /// The exact format pattern used varies by locale.
  ///
  /// The locale is determined from the formatter. The formatter returned directly by
  /// this method will use the Locale\#getDefault(Locale.Category) default FORMAT locale.
  /// The locale can be controlled using DateTimeFormatter\#withLocale(Locale) withLocale(Locale)
  /// on the result of this method.
  ///
  /// Note that the localized pattern is looked up lazily.
  /// This {@code DateTimeFormatter} holds the style required and the locale,
  /// looking up the pattern required on demand.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#SMART SMART resolver style.
  ///@param dateStyle the formatter style to obtain, not null
  ///@return the date formatter, not null
  static DateTimeFormatter? ofLocalizedDate(jni$_.JObject? dateStyle) {
    final _$dateStyle = dateStyle?.reference ?? jni$_.jNullReference;
    return _ofLocalizedDate(
      _class.reference.pointer,
      _id_ofLocalizedDate as jni$_.JMethodIDPtr,
      _$dateStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_ofLocalizedTime = _class.staticMethodId(
    r'ofLocalizedTime',
    r'(Ljava/time/format/FormatStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofLocalizedTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofLocalizedTime(java.time.format.FormatStyle timeStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a locale specific time format for the ISO chronology.
  ///
  /// This returns a formatter that will format or parse a time.
  /// The exact format pattern used varies by locale.
  ///
  /// The locale is determined from the formatter. The formatter returned directly by
  /// this method will use the Locale\#getDefault(Locale.Category) default FORMAT locale.
  /// The locale can be controlled using DateTimeFormatter\#withLocale(Locale) withLocale(Locale)
  /// on the result of this method.
  ///
  /// Note that the localized pattern is looked up lazily.
  /// This {@code DateTimeFormatter} holds the style required and the locale,
  /// looking up the pattern required on demand.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#SMART SMART resolver style.
  /// The {@code FULL} and {@code LONG} styles typically require a time-zone.
  /// When formatting using these styles, a {@code ZoneId} must be available,
  /// either by using {@code ZonedDateTime} or DateTimeFormatter\#withZone.
  ///@param timeStyle the formatter style to obtain, not null
  ///@return the time formatter, not null
  static DateTimeFormatter? ofLocalizedTime(jni$_.JObject? timeStyle) {
    final _$timeStyle = timeStyle?.reference ?? jni$_.jNullReference;
    return _ofLocalizedTime(
      _class.reference.pointer,
      _id_ofLocalizedTime as jni$_.JMethodIDPtr,
      _$timeStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_ofLocalizedDateTime = _class.staticMethodId(
    r'ofLocalizedDateTime',
    r'(Ljava/time/format/FormatStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofLocalizedDateTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle dateTimeStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a locale specific date-time formatter for the ISO chronology.
  ///
  /// This returns a formatter that will format or parse a date-time.
  /// The exact format pattern used varies by locale.
  ///
  /// The locale is determined from the formatter. The formatter returned directly by
  /// this method will use the Locale\#getDefault(Locale.Category) default FORMAT locale.
  /// The locale can be controlled using DateTimeFormatter\#withLocale(Locale) withLocale(Locale)
  /// on the result of this method.
  ///
  /// Note that the localized pattern is looked up lazily.
  /// This {@code DateTimeFormatter} holds the style required and the locale,
  /// looking up the pattern required on demand.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#SMART SMART resolver style.
  /// The {@code FULL} and {@code LONG} styles typically require a time-zone.
  /// When formatting using these styles, a {@code ZoneId} must be available,
  /// either by using {@code ZonedDateTime} or DateTimeFormatter\#withZone.
  ///@param dateTimeStyle the formatter style to obtain, not null
  ///@return the date-time formatter, not null
  static DateTimeFormatter? ofLocalizedDateTime(jni$_.JObject? dateTimeStyle) {
    final _$dateTimeStyle = dateTimeStyle?.reference ?? jni$_.jNullReference;
    return _ofLocalizedDateTime(
      _class.reference.pointer,
      _id_ofLocalizedDateTime as jni$_.JMethodIDPtr,
      _$dateTimeStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_ofLocalizedDateTime$1 = _class.staticMethodId(
    r'ofLocalizedDateTime',
    r'(Ljava/time/format/FormatStyle;Ljava/time/format/FormatStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _ofLocalizedDateTime$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.time.format.DateTimeFormatter ofLocalizedDateTime(java.time.format.FormatStyle dateStyle, java.time.format.FormatStyle timeStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a locale specific date and time format for the ISO chronology.
  ///
  /// This returns a formatter that will format or parse a date-time.
  /// The exact format pattern used varies by locale.
  ///
  /// The locale is determined from the formatter. The formatter returned directly by
  /// this method will use the Locale\#getDefault() default FORMAT locale.
  /// The locale can be controlled using DateTimeFormatter\#withLocale(Locale) withLocale(Locale)
  /// on the result of this method.
  ///
  /// Note that the localized pattern is looked up lazily.
  /// This {@code DateTimeFormatter} holds the style required and the locale,
  /// looking up the pattern required on demand.
  ///
  /// The returned formatter has a chronology of ISO set to ensure dates in
  /// other calendar systems are correctly converted.
  /// It has no override zone and uses the ResolverStyle\#SMART SMART resolver style.
  /// The {@code FULL} and {@code LONG} styles typically require a time-zone.
  /// When formatting using these styles, a {@code ZoneId} must be available,
  /// either by using {@code ZonedDateTime} or DateTimeFormatter\#withZone.
  ///@param dateStyle the date formatter style to obtain, not null
  ///@param timeStyle the time formatter style to obtain, not null
  ///@return the date, time or date-time formatter, not null
  static DateTimeFormatter? ofLocalizedDateTime$1(jni$_.JObject? dateStyle, jni$_.JObject? timeStyle) {
    final _$dateStyle = dateStyle?.reference ?? jni$_.jNullReference;
    final _$timeStyle = timeStyle?.reference ?? jni$_.jNullReference;
    return _ofLocalizedDateTime$1(
      _class.reference.pointer,
      _id_ofLocalizedDateTime$1 as jni$_.JMethodIDPtr,
      _$dateStyle.pointer,
      _$timeStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_parsedExcessDays = _class.staticMethodId(
    r'parsedExcessDays',
    r'()Ljava/time/temporal/TemporalQuery;',
  );

  static final _parsedExcessDays =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public final java.time.temporal.TemporalQuery<java.time.Period> parsedExcessDays()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A query that provides access to the excess days that were parsed.
  ///
  /// This returns a singleton {@linkplain TemporalQuery query} that provides
  /// access to additional information from the parse. The query always returns
  /// a non-null period, with a zero period returned instead of null.
  ///
  /// There are two situations where this query may return a non-zero period.
  /// <ul>
  /// <li>If the {@code ResolverStyle} is {@code LENIENT} and a time is parsed
  ///  without a date, then the complete result of the parse consists of a
  ///  {@code LocalTime} and an excess {@code Period} in days.
  ///
  /// <li>If the {@code ResolverStyle} is {@code SMART} and a time is parsed
  ///  without a date where the time is 24:00:00, then the complete result of
  ///  the parse consists of a {@code LocalTime} of 00:00:00 and an excess
  ///  {@code Period} of one day.
  /// </ul>
  ///
  /// In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}
  /// is parsed, then the excess days are added to the date part.
  /// As a result, this query will return a zero period.
  ///
  /// The {@code SMART} behaviour handles the common "end of day" 24:00 value.
  /// Processing in {@code LENIENT} mode also produces the same result:
  /// <pre>
  ///  Text to parse        Parsed object                         Excess days
  ///  "2012-12-03T00:00"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
  ///  "2012-12-03T24:00"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
  ///  "00:00"              LocalTime.of(0, 0)                    ZERO
  ///  "24:00"              LocalTime.of(0, 0)                    Period.ofDays(1)
  /// </pre>
  /// The query can be used as follows:
  /// <pre>
  ///  TemporalAccessor parsed = formatter.parse(str);
  ///  LocalTime time = parsed.query(LocalTime::from);
  ///  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());
  /// </pre>
  ///@return a query that provides access to the excess days that were parsed
  static jni$_.JObject? parsedExcessDays() {
    return _parsedExcessDays(
      _class.reference.pointer,
      _id_parsedExcessDays as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parsedLeapSecond = _class.staticMethodId(
    r'parsedLeapSecond',
    r'()Ljava/time/temporal/TemporalQuery;',
  );

  static final _parsedLeapSecond =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallStaticObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `static public final java.time.temporal.TemporalQuery<java.lang.Boolean> parsedLeapSecond()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A query that provides access to whether a leap-second was parsed.
  ///
  /// This returns a singleton {@linkplain TemporalQuery query} that provides
  /// access to additional information from the parse. The query always returns
  /// a non-null boolean, true if parsing saw a leap-second, false if not.
  ///
  /// Instant parsing handles the special "leap second" time of '23:59:60'.
  /// Leap seconds occur at '23:59:60' in the UTC time-zone, but at other
  /// local times in different time-zones. To avoid this potential ambiguity,
  /// the handling of leap-seconds is limited to
  /// DateTimeFormatterBuilder\#appendInstant(), as that method
  /// always parses the instant with the UTC zone offset.
  ///
  /// If the time '23:59:60' is received, then a simple conversion is applied,
  /// replacing the second-of-minute of 60 with 59. This query can be used
  /// on the parse result to determine if the leap-second adjustment was made.
  /// The query will return {@code true} if it did adjust to remove the
  /// leap-second, and {@code false} if not. Note that applying a leap-second
  /// smoothing mechanism, such as UTC-SLS, is the responsibility of the
  /// application, as follows:
  /// <pre>
  ///  TemporalAccessor parsed = formatter.parse(str);
  ///  Instant instant = parsed.query(Instant::from);
  ///  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
  ///    // validate leap-second is correct and apply correct smoothing
  ///  }
  /// </pre>
  ///@return a query that provides access to whether a leap-second was parsed
  static jni$_.JObject? parsedLeapSecond() {
    return _parsedLeapSecond(
      _class.reference.pointer,
      _id_parsedLeapSecond as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getLocale = _class.instanceMethodId(r'getLocale', r'()Ljava/util/Locale;');

  static final _getLocale =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.util.Locale getLocale()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the locale to be used during formatting.
  ///
  /// This is used to lookup any part of the formatter needing specific
  /// localization, such as the text or localized pattern.
  ///@return the locale of this formatter, not null
  jni$_.JObject? getLocale() {
    return _getLocale(
      reference.pointer,
      _id_getLocale as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withLocale = _class.instanceMethodId(
    r'withLocale',
    r'(Ljava/util/Locale;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withLocale(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new locale.
  ///
  /// This is used to lookup any part of the formatter needing specific
  /// localization, such as the text or localized pattern.
  ///
  /// The locale is stored as passed in, without further processing.
  /// If the locale has <a href="../../util/Locale.html\#def_locale_extension">
  /// Unicode extensions</a>, they may be used later in text
  /// processing. To set the chronology, time-zone and decimal style from
  /// unicode extensions, see \#localizedBy localizedBy().
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param locale the new locale, not null
  ///@return a formatter based on this formatter with the requested locale, not null
  ///@see \#localizedBy(Locale)
  DateTimeFormatter? withLocale(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _withLocale(
      reference.pointer,
      _id_withLocale as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_localizedBy = _class.instanceMethodId(
    r'localizedBy',
    r'(Ljava/util/Locale;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _localizedBy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter localizedBy(java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with localized values of the locale,
  /// calendar, region, decimal style and/or timezone, that supercede values in
  /// this formatter.
  ///
  /// This is used to lookup any part of the formatter needing specific
  /// localization, such as the text or localized pattern. If the locale contains the
  /// "ca" (calendar), "nu" (numbering system), "rg" (region override), and/or
  /// "tz" (timezone)
  /// <a href="../../util/Locale.html\#def_locale_extension">Unicode extensions</a>,
  /// the chronology, numbering system and/or the zone are overridden. If both "ca"
  /// and "rg" are specified, the chronology from the "ca" extension supersedes the
  /// implicit one from the "rg" extension. Same is true for the "nu" extension.
  ///
  /// Unlike the \#withLocale withLocale method, the call to this method may
  /// produce a different formatter depending on the order of method chaining with
  /// other withXXXX() methods.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param locale the locale, not null
  ///@return a formatter based on this formatter with localized values of
  ///      the calendar, decimal style and/or timezone, that supercede values in this
  ///      formatter.
  ///@see \#withLocale(Locale)
  ///@since 10
  DateTimeFormatter? localizedBy(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _localizedBy(
      reference.pointer,
      _id_localizedBy as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_getDecimalStyle = _class.instanceMethodId(r'getDecimalStyle', r'()Ljava/time/format/DecimalStyle;');

  static final _getDecimalStyle =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.format.DecimalStyle getDecimalStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the DecimalStyle to be used during formatting.
  ///@return the locale of this formatter, not null
  jni$_.JObject? getDecimalStyle() {
    return _getDecimalStyle(
      reference.pointer,
      _id_getDecimalStyle as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withDecimalStyle = _class.instanceMethodId(
    r'withDecimalStyle',
    r'(Ljava/time/format/DecimalStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withDecimalStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withDecimalStyle(java.time.format.DecimalStyle decimalStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new DecimalStyle.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param decimalStyle the new DecimalStyle, not null
  ///@return a formatter based on this formatter with the requested DecimalStyle, not null
  DateTimeFormatter? withDecimalStyle(jni$_.JObject? decimalStyle) {
    final _$decimalStyle = decimalStyle?.reference ?? jni$_.jNullReference;
    return _withDecimalStyle(
      reference.pointer,
      _id_withDecimalStyle as jni$_.JMethodIDPtr,
      _$decimalStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_getChronology = _class.instanceMethodId(r'getChronology', r'()Ljava/time/chrono/Chronology;');

  static final _getChronology =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.chrono.Chronology getChronology()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the overriding chronology to be used during formatting.
  ///
  /// This returns the override chronology, used to convert dates.
  /// By default, a formatter has no override chronology, returning null.
  /// See \#withChronology(Chronology) for more details on overriding.
  ///@return the override chronology of this formatter, null if no override
  jni$_.JObject? getChronology() {
    return _getChronology(
      reference.pointer,
      _id_getChronology as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withChronology = _class.instanceMethodId(
    r'withChronology',
    r'(Ljava/time/chrono/Chronology;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withChronology =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withChronology(java.time.chrono.Chronology chrono)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new override chronology.
  ///
  /// This returns a formatter with similar state to this formatter but
  /// with the override chronology set.
  /// By default, a formatter has no override chronology, returning null.
  ///
  /// If an override is added, then any date that is formatted or parsed will be affected.
  ///
  /// When formatting, if the temporal object contains a date, then it will
  /// be converted to a date in the override chronology.
  /// Whether the temporal contains a date is determined by querying the
  /// ChronoField\#EPOCH_DAY EPOCH_DAY field.
  /// Any time or zone will be retained unaltered unless overridden.
  ///
  /// If the temporal object does not contain a date, but does contain one
  /// or more {@code ChronoField} date fields, then a {@code DateTimeException}
  /// is thrown. In all other cases, the override chronology is added to the temporal,
  /// replacing any previous chronology, but without changing the date/time.
  ///
  /// When parsing, there are two distinct cases to consider.
  /// If a chronology has been parsed directly from the text, perhaps because
  /// DateTimeFormatterBuilder\#appendChronologyId() was used, then
  /// this override chronology has no effect.
  /// If no zone has been parsed, then this override chronology will be used
  /// to interpret the {@code ChronoField} values into a date according to the
  /// date resolving rules of the chronology.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param chrono the new chronology, null if no override
  ///@return a formatter based on this formatter with the requested override chronology, not null
  DateTimeFormatter? withChronology(jni$_.JObject? chrono) {
    final _$chrono = chrono?.reference ?? jni$_.jNullReference;
    return _withChronology(
      reference.pointer,
      _id_withChronology as jni$_.JMethodIDPtr,
      _$chrono.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(r'getZone', r'()Ljava/time/ZoneId;');

  static final _getZone =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the overriding zone to be used during formatting.
  ///
  /// This returns the override zone, used to convert instants.
  /// By default, a formatter has no override zone, returning null.
  /// See \#withZone(ZoneId) for more details on overriding.
  ///@return the override zone of this formatter, null if no override
  ZoneId? getZone() {
    return _getZone(reference.pointer, _id_getZone as jni$_.JMethodIDPtr).object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_withZone = _class.instanceMethodId(
    r'withZone',
    r'(Ljava/time/ZoneId;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withZone(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new override zone.
  ///
  /// This returns a formatter with similar state to this formatter but
  /// with the override zone set.
  /// By default, a formatter has no override zone, returning null.
  ///
  /// If an override is added, then any instant that is formatted or parsed will be affected.
  ///
  /// When formatting, if the temporal object contains an instant, then it will
  /// be converted to a zoned date-time using the override zone.
  /// Whether the temporal is an instant is determined by querying the
  /// ChronoField\#INSTANT_SECONDS INSTANT_SECONDS field.
  /// If the input has a chronology then it will be retained unless overridden.
  /// If the input does not have a chronology, such as {@code Instant}, then
  /// the ISO chronology will be used.
  ///
  /// If the temporal object does not contain an instant, but does contain
  /// an offset then an additional check is made. If the normalized override
  /// zone is an offset that differs from the offset of the temporal, then
  /// a {@code DateTimeException} is thrown. In all other cases, the override
  /// zone is added to the temporal, replacing any previous zone, but without
  /// changing the date/time.
  ///
  /// When parsing, there are two distinct cases to consider.
  /// If a zone has been parsed directly from the text, perhaps because
  /// DateTimeFormatterBuilder\#appendZoneId() was used, then
  /// this override zone has no effect.
  /// If no zone has been parsed, then this override zone will be included in
  /// the result of the parse where it can be used to build instants and date-times.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param zone the new override zone, null if no override
  ///@return a formatter based on this formatter with the requested override zone, not null
  DateTimeFormatter? withZone(ZoneId? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _withZone(
      reference.pointer,
      _id_withZone as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_getResolverStyle = _class.instanceMethodId(
    r'getResolverStyle',
    r'()Ljava/time/format/ResolverStyle;',
  );

  static final _getResolverStyle =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.time.format.ResolverStyle getResolverStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the resolver style to use during parsing.
  ///
  /// This returns the resolver style, used during the second phase of parsing
  /// when fields are resolved into dates and times.
  /// By default, a formatter has the ResolverStyle\#SMART SMART resolver style.
  /// See \#withResolverStyle(ResolverStyle) for more details.
  ///@return the resolver style of this formatter, not null
  jni$_.JObject? getResolverStyle() {
    return _getResolverStyle(
      reference.pointer,
      _id_getResolverStyle as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_withResolverStyle = _class.instanceMethodId(
    r'withResolverStyle',
    r'(Ljava/time/format/ResolverStyle;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withResolverStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withResolverStyle(java.time.format.ResolverStyle resolverStyle)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new resolver style.
  ///
  /// This returns a formatter with similar state to this formatter but
  /// with the resolver style set. By default, a formatter has the
  /// ResolverStyle\#SMART SMART resolver style.
  ///
  /// Changing the resolver style only has an effect during parsing.
  /// Parsing a text string occurs in two phases.
  /// Phase 1 is a basic text parse according to the fields added to the builder.
  /// Phase 2 resolves the parsed field-value pairs into date and/or time objects.
  /// The resolver style is used to control how phase 2, resolving, happens.
  /// See {@code ResolverStyle} for more information on the options available.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param resolverStyle the new resolver style, not null
  ///@return a formatter based on this formatter with the requested resolver style, not null
  DateTimeFormatter? withResolverStyle(jni$_.JObject? resolverStyle) {
    final _$resolverStyle = resolverStyle?.reference ?? jni$_.jNullReference;
    return _withResolverStyle(
      reference.pointer,
      _id_withResolverStyle as jni$_.JMethodIDPtr,
      _$resolverStyle.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_getResolverFields = _class.instanceMethodId(r'getResolverFields', r'()Ljava/util/Set;');

  static final _getResolverFields =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.util.Set<java.time.temporal.TemporalField> getResolverFields()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the resolver fields to use during parsing.
  ///
  /// This returns the resolver fields, used during the second phase of parsing
  /// when fields are resolved into dates and times.
  /// By default, a formatter has no resolver fields, and thus returns null.
  /// See \#withResolverFields(Set) for more details.
  ///@return the immutable set of resolver fields of this formatter, null if no fields
  jni$_.JSet<jni$_.JObject?>? getResolverFields() {
    return _getResolverFields(
      reference.pointer,
      _id_getResolverFields as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JObject?>?>(const jni$_.JSetNullableType<jni$_.JObject?>(jni$_.JObjectNullableType()));
  }

  static final _id_withResolverFields = _class.instanceMethodId(
    r'withResolverFields',
    r'([Ljava/time/temporal/TemporalField;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withResolverFields =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withResolverFields(java.time.temporal.TemporalField[] resolverFields)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new set of resolver fields.
  ///
  /// This returns a formatter with similar state to this formatter but with
  /// the resolver fields set. By default, a formatter has no resolver fields.
  ///
  /// Changing the resolver fields only has an effect during parsing.
  /// Parsing a text string occurs in two phases.
  /// Phase 1 is a basic text parse according to the fields added to the builder.
  /// Phase 2 resolves the parsed field-value pairs into date and/or time objects.
  /// The resolver fields are used to filter the field-value pairs between phase 1 and 2.
  ///
  /// This can be used to select between two or more ways that a date or time might
  /// be resolved. For example, if the formatter consists of year, month, day-of-month
  /// and day-of-year, then there are two ways to resolve a date.
  /// Calling this method with the arguments ChronoField\#YEAR YEAR and
  /// ChronoField\#DAY_OF_YEAR DAY_OF_YEAR will ensure that the date is
  /// resolved using the year and day-of-year, effectively meaning that the month
  /// and day-of-month are ignored during the resolving phase.
  ///
  /// In a similar manner, this method can be used to ignore secondary fields that
  /// would otherwise be cross-checked. For example, if the formatter consists of year,
  /// month, day-of-month and day-of-week, then there is only one way to resolve a
  /// date, but the parsed value for day-of-week will be cross-checked against the
  /// resolved date. Calling this method with the arguments ChronoField\#YEAR YEAR,
  /// ChronoField\#MONTH_OF_YEAR MONTH_OF_YEAR and
  /// ChronoField\#DAY_OF_MONTH DAY_OF_MONTH will ensure that the date is
  /// resolved correctly, but without any cross-check for the day-of-week.
  ///
  /// In implementation terms, this method behaves as follows. The result of the
  /// parsing phase can be considered to be a map of field to value. The behavior
  /// of this method is to cause that map to be filtered between phase 1 and 2,
  /// removing all fields other than those specified as arguments to this method.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param resolverFields the new set of resolver fields, null if no fields
  ///@return a formatter based on this formatter with the requested resolver style, not null
  DateTimeFormatter? withResolverFields(jni$_.JArray<jni$_.JObject?>? resolverFields) {
    final _$resolverFields = resolverFields?.reference ?? jni$_.jNullReference;
    return _withResolverFields(
      reference.pointer,
      _id_withResolverFields as jni$_.JMethodIDPtr,
      _$resolverFields.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_withResolverFields$1 = _class.instanceMethodId(
    r'withResolverFields',
    r'(Ljava/util/Set;)Ljava/time/format/DateTimeFormatter;',
  );

  static final _withResolverFields$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.format.DateTimeFormatter withResolverFields(java.util.Set<java.time.temporal.TemporalField> resolverFields)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this formatter with a new set of resolver fields.
  ///
  /// This returns a formatter with similar state to this formatter but with
  /// the resolver fields set. By default, a formatter has no resolver fields.
  ///
  /// Changing the resolver fields only has an effect during parsing.
  /// Parsing a text string occurs in two phases.
  /// Phase 1 is a basic text parse according to the fields added to the builder.
  /// Phase 2 resolves the parsed field-value pairs into date and/or time objects.
  /// The resolver fields are used to filter the field-value pairs between phase 1 and 2.
  ///
  /// This can be used to select between two or more ways that a date or time might
  /// be resolved. For example, if the formatter consists of year, month, day-of-month
  /// and day-of-year, then there are two ways to resolve a date.
  /// Calling this method with the arguments ChronoField\#YEAR YEAR and
  /// ChronoField\#DAY_OF_YEAR DAY_OF_YEAR will ensure that the date is
  /// resolved using the year and day-of-year, effectively meaning that the month
  /// and day-of-month are ignored during the resolving phase.
  ///
  /// In a similar manner, this method can be used to ignore secondary fields that
  /// would otherwise be cross-checked. For example, if the formatter consists of year,
  /// month, day-of-month and day-of-week, then there is only one way to resolve a
  /// date, but the parsed value for day-of-week will be cross-checked against the
  /// resolved date. Calling this method with the arguments ChronoField\#YEAR YEAR,
  /// ChronoField\#MONTH_OF_YEAR MONTH_OF_YEAR and
  /// ChronoField\#DAY_OF_MONTH DAY_OF_MONTH will ensure that the date is
  /// resolved correctly, but without any cross-check for the day-of-week.
  ///
  /// In implementation terms, this method behaves as follows. The result of the
  /// parsing phase can be considered to be a map of field to value. The behavior
  /// of this method is to cause that map to be filtered between phase 1 and 2,
  /// removing all fields other than those specified as arguments to this method.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param resolverFields the new set of resolver fields, null if no fields
  ///@return a formatter based on this formatter with the requested resolver style, not null
  DateTimeFormatter? withResolverFields$1(jni$_.JSet<jni$_.JObject?>? resolverFields) {
    final _$resolverFields = resolverFields?.reference ?? jni$_.jNullReference;
    return _withResolverFields$1(
      reference.pointer,
      _id_withResolverFields$1 as jni$_.JMethodIDPtr,
      _$resolverFields.pointer,
    ).object<DateTimeFormatter?>(const $DateTimeFormatter$NullableType());
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/lang/String;',
  );

  static final _format =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.lang.String format(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Formats a date-time object using this formatter.
  ///
  /// This formats the date-time to a String using the rules of the formatter.
  ///@param temporal the temporal object to format, not null
  ///@return the formatted string, not null
  ///@throws DateTimeException if an error occurs during formatting
  jni$_.JString? format(jni$_.JObject? temporal) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _format(
      reference.pointer,
      _id_format as jni$_.JMethodIDPtr,
      _$temporal.pointer,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_formatTo = _class.instanceMethodId(
    r'formatTo',
    r'(Ljava/time/temporal/TemporalAccessor;Ljava/lang/Appendable;)V',
  );

  static final _formatTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void formatTo(java.time.temporal.TemporalAccessor temporal, java.lang.Appendable appendable)`
  ///
  /// Formats a date-time object to an {@code Appendable} using this formatter.
  ///
  /// This outputs the formatted date-time to the specified destination.
  /// Appendable is a general purpose interface that is implemented by all
  /// key character output classes including {@code StringBuffer}, {@code StringBuilder},
  /// {@code PrintStream} and {@code Writer}.
  ///
  /// Although {@code Appendable} methods throw an {@code IOException}, this method does not.
  /// Instead, any {@code IOException} is wrapped in a runtime exception.
  ///@param temporal the temporal object to format, not null
  ///@param appendable the appendable to format to, not null
  ///@throws DateTimeException if an error occurs during formatting
  void formatTo(jni$_.JObject? temporal, jni$_.JObject? appendable) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    final _$appendable = appendable?.reference ?? jni$_.jNullReference;
    _formatTo(reference.pointer, _id_formatTo as jni$_.JMethodIDPtr, _$temporal.pointer, _$appendable.pointer).check();
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/temporal/TemporalAccessor;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.time.temporal.TemporalAccessor parse(java.lang.CharSequence text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fully parses the text producing a temporal object.
  ///
  /// This parses the entire text producing a temporal object.
  /// It is typically more useful to use \#parse(CharSequence, TemporalQuery).
  /// The result of this method is {@code TemporalAccessor} which has been resolved,
  /// applying basic validation checks to help ensure a valid date-time.
  ///
  /// If the parse completes without reading the entire length of the text,
  /// or a problem occurs during parsing or merging, then an exception is thrown.
  ///@param text the text to parse, not null
  ///@return the parsed temporal object, not null
  ///@throws DateTimeParseException if unable to parse the requested result
  jni$_.JObject? parse(jni$_.JObject? text) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parse$1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/text/ParsePosition;)Ljava/time/temporal/TemporalAccessor;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.TemporalAccessor parse(java.lang.CharSequence text, java.text.ParsePosition position)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses the text using this formatter, providing control over the text position.
  ///
  /// This parses the text without requiring the parse to start from the beginning
  /// of the string or finish at the end.
  /// The result of this method is {@code TemporalAccessor} which has been resolved,
  /// applying basic validation checks to help ensure a valid date-time.
  ///
  /// The text will be parsed from the specified start {@code ParsePosition}.
  /// The entire length of the text does not have to be parsed, the {@code ParsePosition}
  /// will be updated with the index at the end of parsing.
  ///
  /// The operation of this method is slightly different to similar methods using
  /// {@code ParsePosition} on {@code java.text.Format}. That class will return
  /// errors using the error index on the {@code ParsePosition}. By contrast, this
  /// method will throw a DateTimeParseException if an error occurs, with
  /// the exception containing the error index.
  /// This change in behavior is necessary due to the increased complexity of
  /// parsing and resolving dates/times in this API.
  ///
  /// If the formatter parses the same field more than once with different values,
  /// the result will be an error.
  ///@param text the text to parse, not null
  ///@param position the position to parse from, updated with length parsed
  ///  and the index of any error, not null
  ///@return the parsed temporal object, not null
  ///@throws DateTimeParseException if unable to parse the requested result
  ///@throws IndexOutOfBoundsException if the position is invalid
  jni$_.JObject? parse$1(jni$_.JObject? text, jni$_.JObject? position) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$position = position?.reference ?? jni$_.jNullReference;
    return _parse$1(
      reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$text.pointer,
      _$position.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parse$2 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _parse$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T parse(java.lang.CharSequence text, java.time.temporal.TemporalQuery<T> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fully parses the text producing an object of the specified type.
  ///
  /// Most applications should use this method for parsing.
  /// It parses the entire text to produce the required date-time.
  /// The query is typically a method reference to a {@code from(TemporalAccessor)} method.
  /// For example:
  /// <pre>
  ///  LocalDateTime dt = parser.parse(str, LocalDateTime::from);
  /// </pre>
  /// If the parse completes without reading the entire length of the text,
  /// or a problem occurs during parsing or merging, then an exception is thrown.
  ///@param <T> the type of the parsed date-time
  ///@param text the text to parse, not null
  ///@param query the query defining the type to parse to, not null
  ///@return the parsed date-time, not null
  ///@throws DateTimeParseException if unable to parse the requested result
  $T? parse$2<$T extends jni$_.JObject?>(jni$_.JObject? text, jni$_.JObject? query, {required jni$_.JObjType<$T> T}) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _parse$2(
      reference.pointer,
      _id_parse$2 as jni$_.JMethodIDPtr,
      _$text.pointer,
      _$query.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_parseBest = _class.instanceMethodId(
    r'parseBest',
    r'(Ljava/lang/CharSequence;[Ljava/time/temporal/TemporalQuery;)Ljava/time/temporal/TemporalAccessor;',
  );

  static final _parseBest =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.TemporalAccessor parseBest(java.lang.CharSequence text, java.time.temporal.TemporalQuery<?>[] queries)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fully parses the text producing an object of one of the specified types.
  ///
  /// This parse method is convenient for use when the parser can handle optional elements.
  /// For example, a pattern of 'uuuu-MM-dd HH.mm[ VV]' can be fully parsed to a {@code ZonedDateTime},
  /// or partially parsed to a {@code LocalDateTime}.
  /// The queries must be specified in order, starting from the best matching full-parse option
  /// and ending with the worst matching minimal parse option.
  /// The query is typically a method reference to a {@code from(TemporalAccessor)} method.
  ///
  /// The result is associated with the first type that successfully parses.
  /// Normally, applications will use {@code instanceof} to check the result.
  /// For example:
  /// <pre>
  ///  TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
  ///  if (dt instanceof ZonedDateTime) {
  ///   ...
  ///  } else {
  ///   ...
  ///  }
  /// </pre>
  /// If the parse completes without reading the entire length of the text,
  /// or a problem occurs during parsing or merging, then an exception is thrown.
  ///@param text the text to parse, not null
  ///@param queries the queries defining the types to attempt to parse to,
  ///  must implement {@code TemporalAccessor}, not null
  ///@return the parsed date-time, not null
  ///@throws IllegalArgumentException if less than 2 types are specified
  ///@throws DateTimeParseException if unable to parse the requested result
  jni$_.JObject? parseBest(jni$_.JObject? text, jni$_.JArray<jni$_.JObject?>? queries) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$queries = queries?.reference ?? jni$_.jNullReference;
    return _parseBest(
      reference.pointer,
      _id_parseBest as jni$_.JMethodIDPtr,
      _$text.pointer,
      _$queries.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_parseUnresolved = _class.instanceMethodId(
    r'parseUnresolved',
    r'(Ljava/lang/CharSequence;Ljava/text/ParsePosition;)Ljava/time/temporal/TemporalAccessor;',
  );

  static final _parseUnresolved =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.time.temporal.TemporalAccessor parseUnresolved(java.lang.CharSequence text, java.text.ParsePosition position)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parses the text using this formatter, without resolving the result, intended
  /// for advanced use cases.
  ///
  /// Parsing is implemented as a two-phase operation.
  /// First, the text is parsed using the layout defined by the formatter, producing
  /// a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
  /// Second, the parsed data is _resolved_, by validating, combining and
  /// simplifying the various fields into more useful ones.
  /// This method performs the parsing stage but not the resolving stage.
  ///
  /// The result of this method is {@code TemporalAccessor} which represents the
  /// data as seen in the input. Values are not validated, thus parsing a date string
  /// of '2012-00-65' would result in a temporal with three fields - year of '2012',
  /// month of '0' and day-of-month of '65'.
  ///
  /// The text will be parsed from the specified start {@code ParsePosition}.
  /// The entire length of the text does not have to be parsed, the {@code ParsePosition}
  /// will be updated with the index at the end of parsing.
  ///
  /// Errors are returned using the error index field of the {@code ParsePosition}
  /// instead of {@code DateTimeParseException}.
  /// The returned error index will be set to an index indicative of the error.
  /// Callers must check for errors before using the result.
  ///
  /// If the formatter parses the same field more than once with different values,
  /// the result will be an error.
  ///
  /// This method is intended for advanced use cases that need access to the
  /// internal state during parsing. Typical application code should use
  /// \#parse(CharSequence, TemporalQuery) or the parse method on the target type.
  ///@param text the text to parse, not null
  ///@param position the position to parse from, updated with length parsed
  ///  and the index of any error, not null
  ///@return the parsed text, null if the parse results in an error
  ///@throws DateTimeException if some problem occurs during parsing
  ///@throws IndexOutOfBoundsException if the position is invalid
  jni$_.JObject? parseUnresolved(jni$_.JObject? text, jni$_.JObject? position) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$position = position?.reference ?? jni$_.jNullReference;
    return _parseUnresolved(
      reference.pointer,
      _id_parseUnresolved as jni$_.JMethodIDPtr,
      _$text.pointer,
      _$position.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toFormat = _class.instanceMethodId(r'toFormat', r'()Ljava/text/Format;');

  static final _toFormat =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.text.Format toFormat()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns this formatter as a {@code java.text.Format} instance.
  ///
  /// The returned Format instance will format any TemporalAccessor
  /// and parses to a resolved TemporalAccessor.
  ///
  /// Exceptions will follow the definitions of {@code Format}, see those methods
  /// for details about {@code IllegalArgumentException} during formatting and
  /// {@code ParseException} or null during parsing.
  /// The format does not support attributing of the returned format string.
  ///@return this formatter as a classic format instance, not null
  jni$_.JObject? toFormat() {
    return _toFormat(
      reference.pointer,
      _id_toFormat as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toFormat$1 = _class.instanceMethodId(
    r'toFormat',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/text/Format;',
  );

  static final _toFormat$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.text.Format toFormat(java.time.temporal.TemporalQuery<?> parseQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns this formatter as a {@code java.text.Format} instance that will
  /// parse using the specified query.
  ///
  /// The returned Format instance will format any TemporalAccessor
  /// and parses to the type specified.
  /// The type must be one that is supported by \#parse.
  ///
  /// Exceptions will follow the definitions of {@code Format}, see those methods
  /// for details about {@code IllegalArgumentException} during formatting and
  /// {@code ParseException} or null during parsing.
  /// The format does not support attributing of the returned format string.
  ///@param parseQuery the query defining the type to parse to, not null
  ///@return this formatter as a classic format instance, not null
  jni$_.JObject? toFormat$1(jni$_.JObject? parseQuery) {
    final _$parseQuery = parseQuery?.reference ?? jni$_.jNullReference;
    return _toFormat$1(
      reference.pointer,
      _id_toFormat$1 as jni$_.JMethodIDPtr,
      _$parseQuery.pointer,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toString$1 = _class.instanceMethodId(r'toString', r'()Ljava/lang/String;');

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
        jni$_.NativeFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>
      >(
        'globalEnv_CallObjectMethod',
      ).asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr)>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a description of the underlying formatters.
  ///@return a description of this formatter, not null
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $DateTimeFormatter$NullableType extends jni$_.JObjType<DateTimeFormatter?> {
  @jni$_.internal
  const $DateTimeFormatter$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/format/DateTimeFormatter;';

  @jni$_.internal
  @core$_.override
  DateTimeFormatter? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : DateTimeFormatter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeFormatter?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeFormatter$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DateTimeFormatter$NullableType) && other is $DateTimeFormatter$NullableType;
  }
}

final class $DateTimeFormatter$Type extends jni$_.JObjType<DateTimeFormatter> {
  @jni$_.internal
  const $DateTimeFormatter$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/format/DateTimeFormatter;';

  @jni$_.internal
  @core$_.override
  DateTimeFormatter fromReference(jni$_.JReference reference) => DateTimeFormatter.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<DateTimeFormatter?> get nullableType => const $DateTimeFormatter$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($DateTimeFormatter$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($DateTimeFormatter$Type) && other is $DateTimeFormatter$Type;
  }
}
